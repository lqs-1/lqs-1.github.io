<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mongoDB使用</title>
      <link href="/2023/01/19/mongodb-shi-yong/"/>
      <url>/2023/01/19/mongodb-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h1><blockquote><ul><li><p>全局说明:文档=字典=map=dict=json </p></li><li><p>$是mongodb的专用字符</p></li></ul></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> mongodb-org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="启动-服务器"><a href="#启动-服务器" class="headerlink" title="启动(服务器):"></a>启动(服务器):</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> mongod start<span class="token function">sudo</span> <span class="token function">service</span> mongod stop<span class="token function">sudo</span> <span class="token function">service</span> mongod restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mongo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="服务环境"><a href="#服务环境" class="headerlink" title="服务环境:"></a>服务环境:</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">mongod://localhost:27017redis://localhost:6379mysql://localhost:3306nginx://localhost:8888tomcat://localhost:8080flask://localhost:5000django://localhost:8000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mongodb的命令"><a href="#mongodb的命令" class="headerlink" title="mongodb的命令"></a>mongodb的命令</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">show dbs: 查看有哪些数据库show database: 查看有哪些数据库use 数据库: 切换到某个数据库,如果没有,直接创建(如果被使用的数据库是没有的,那么也是可以用的,因为mongodb是会自动创建的,但是,如果在创建完成之后没有存入任何数据,那么这个表用完之后,也不会保存)db: 查看当前数据库(代表当前数据库)db.dropDatabase(): 删除当前使用的数据库mongodb没有表的概念 数据都存储在集合当中集合也是不需要自己创建的,可以在存入数据的时候,mongodb自动创建集合也可以手动创建集合db.createCollection(name, options): name 是被创建的这个集合的名字,options是这个集合的一些属性约束,用一个字典来设置db.createCollection("userinfo",&#123;capped:true, size:10&#125;):表示的就是,创建一个叫做userinfo的集合,capped表示限制,默认false,无上限,size是在capped为true的时候设置,表示数据超过10字节的时候,就会被新的数据覆盖,把之前的数据往外挤show cllections: 查看所有的集合db.集合名.drop(): 删除给定的集合db.集合名: 使用指定的集合db.集合名.find(): 查询指定的集合中的数据db.集合名.insert(&#123;"name": "lqs","age":"12"&#125;): 往指定的集合插入数据这是一个Object类型(文档类型,字典),那么他会自动生成一个_id:ObjectId("xxxxxxx"),保证文档的唯一性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">db.集合名.insert(&#123;&#125;)db.集合名.save(&#123;&#125;)两者的区别:    insert()的方式来添加数据的时候,是绝对添加,如果添加一个_id已经存在的数据,那么它会直接报错,说,如果添加一个_id已经存在    save()的方式来添加数据的时候,是相对添加,如果添加一个_id不存在的数据,就和insert()方法一样,如果添加一个_id已经存在的数据,那么就是替换这个数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文档插入"><a href="#文档插入" class="headerlink" title="文档插入"></a>文档插入</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">db.集合名.insert(&#123;_id:value,key:"value",key:"value",...&#125;): key是可以不用引起来,也可以引起,value根据具体数数据类型,字符串就引起,数字就不引起,_id如果自己不设置,系统就会自动生成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">美化查询:db.集合名.find().pretty():db.集合名.find(): 查给定集合的所有数据db.集合名.find(条件 根据这个条件查出对应的数据 字典格式, 返回的字段): 查询出给定集合里满足条件的所有数据db.集合名.findOne(条件 根据这个条件查出对应的数据 字典格式): 查询出给定集合里满足条件的一条数据比较运算符    $lt: 小于    $lte: 小于等于    $gt: 大于    $gte: 大于等于    $ne: 不等使用例子:    db.collection.find(&#123;age:&#123;$lt:18&#125;&#125;):查询出collection集合中的年龄小于18的所有数据范围运算符:    $in: 范围是指定的范围给在数组中    $nin: 不在指定的范围的使用例子:    db.collection.find(&#123;age:&#123;$in:[12,45,23]&#125;&#125;):查询出collection集合中的年龄是12,23,45的人逻辑运算符:    与: 没有直接的运算符,直接写    $or       逻辑或    $and      逻辑与    $not      逻辑非    $nor      逻辑or的取反    $exists   存在逻辑    $type     查询键的数据类型使用例子:    db.collection.find(&#123;$or:[&#123;age:&#123;$lt:18&#125;&#125;,&#123;name:"sc"&#125;]&#125;):查询出collection中的年龄小于18或者名字等于sc的正则:    用/正则表达式/或者$regex:"正则表达式"编写正则表达式使用例子:    db.collection.find(&#123;name:/^abc/&#125;):查询名字是abc开头的    db.collection.find(&#123;name:&#123;$regex:"123$"&#125;&#125;):查询名字是123结尾的limit和skip:    limit: 选中多少个    skip: 跳过多少个    配合使用的时候,先skip再limit使用例子:    db.collection.find().skip(2).limit(2):跳过两个再选中两个自定义查询(写js):    db.collection.find(&#123;$where:function()&#123;return this.age>30&#125;&#125;)    where可以执行一个函数,this就是表示当前collection中的数据,一条一条的来过this,类似于遍历<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询之后返回字段的过滤"><a href="#查询之后返回字段的过滤" class="headerlink" title="查询之后返回字段的过滤"></a>查询之后返回字段的过滤</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">db.collection.find(&#123;条件&#125;,&#123;name:1,_id:0 参数就是返回的字段,1为返回,不写不返回,除了_id,如果不想返回_id,那么_id:0&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><pre class="line-numbers language-none"><code class="language-none">db.collection.find().sort(&#123;排序字段:1, 排序字段:-1&#125;): sort表示排序,1为升序,-1为降序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h4><pre class="line-numbers language-none"><code class="language-none">db.collection.find(&#123;条件&#125;).count()db.collection.count(&#123;条件&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><pre class="line-numbers language-none"><code class="language-none">db.collection.distinct(&quot;字段名字&quot;,&#123;条件&#125;): 返回的是一个列表,列表里面是不重复的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><pre class="line-numbers language-none"><code class="language-none">管道:上层的结果给下层用$sum:总和,统计个数,$sum:1,以一倍计数$avg:平均$min:最小值$max:最大值$push:结果文档插入到一个数组中，$addToSet:结果文档插入到一个数组中,但不创建副本$first:根据资源文档排序获取第一个文档数据,$last:根据资源文档排序获取最后一个文档数据,$limit:显示多少个$skip:跳过多少个$sort:排序$project:修改输入文档的结构,如重命名\添加\删除字段,创建计算结果$unwind:将数组类型的字段进行拆分$match:相当于mysql中where$group:相当于mysql中group bydb.collection.aggregate(pipeline, options):语法:pipeline,管道,必须是一个数组格式:db.collection.aggregate([&#123;管道:&#123;表达式&#125;&#125;,&#123;管道:&#123;表达式&#125;&#125;])管道中使用字段:    不加$:在明确的条件中字段不用加$如&#123;name:&quot;lqs&quot;&#125;:这种表示name是lqs,冒号前面不加    加$:在不明确的使用值的时候加$如&#123;name2:$name&#125;:这种表示获取name的值,冒号后面加例子:    db.collection.aggregate([&#123;$match:&#123;name:&quot;lqs&quot;&#125;&#125;]):查出名字是lqs的    db.collection.aggregate([&#123;$match:&#123;_id:&#123;&quot;$gt&quot;:2&#125;&#125;&#125;,&#123;$group:&#123;_id:$name,aavg:&#123;$avg:$salary&#125;&#125;&#125;]):查出_id大于2的所有数据,在上面查出的数据中,再按照name分组,求出salary的平均,_id表示分组字段的key,分组字段必须加上$,在这里面出现的变量多用$修饰,aavg是别名这种有多个操作的,都是衔接的,必须下面能用    db.collection.aggregate([&#123;$group:&#123;_id:$name,maxM:&#123;$max:$salary&#125;,minM:&#123;$min:$salary&#125;&#125;&#125;]):分组查出最大最小    db.collection.aggregate([&#123;$group:&#123;_id:$sex,count:&#123;$sum:1&#125;&#125;&#125;]):分组统计男女生的总个数    db.collection.aggregate([&#123;$group:&#123;_id:null,count:&#123;$sum:1&#125;&#125;&#125;]):表示查出这个文档的个数,_id&#x3D;null的时候,表示整个文档为一组    上面的各种结果中都一定有一个_id字段,id表示分组依据    db.collection.aggregate([&#123;$group:&#123;_id:$gender,count:&#123;$sum:1&#125;&#125;&#125;,&#123;$[project:&#123;gender:$_id,count:1,_id:0&#125;]&#125;]):表示创建一个gender字段,值为上一个管道的_id的值,count:1表示显示这个字段,_id:0,表示不显示这个字段,也可以使用count:$count来显示,个之前的投影一样的1\0操作    db.collection.aggregate([&#123;$sort:&#123;name:1&#125;&#125;]):按照姓名升序排序    db.collection.aggregate([        &#123;$group:&#123;_id:$gender,count:&#123;$sum:1&#125;&#125;&#125;,        &#123;$project:&#123;_id:0,gender:$_id.gender,count:1&#125;&#125;,        &#123;$sort:&#123;count:1&#125;&#125;    ]) 按照男女生总数升序排列    db.cllection.aggregate([        &#123;$skip:2&#125;,        &#123;$limit:2&#125;    ]) 跳过两条显示两条    原数据:&#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;map&quot;, &quot;size&quot;:[1,2,3]&#125;    db.collection.aggregate([&#123;$unwind:$size&#125;]):将上面的数据中的size对应的列表拆分成三个,这个管道只对列表有用    拆分后:        &#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;map&quot;, &quot;size&quot;:1&#125;        &#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;map&quot;, &quot;size&quot;:2&#125;        &#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;map&quot;, &quot;size&quot;:3&#125;    高级使用:    db.collection.aggregate([        &#123;$group:&#123;_id:&#123;conutry:$conutry,prevent:$prevent,userid:$userid&#125;&#125;&#125;, 将不同国家的不同省份的用户分出来userid用于去重        &#123;$group:&#123;_id:&#123;conutry:$_id.conutry,prevent:$_id.prevent&#125;,conunt:&#123;$sum:1&#125;&#125;&#125;, 在将以上分好的用国家和省份分组统计出总个数        &#123;$project:&#123;_id:0,conutry:$_id.conutry,prevent:$_id.prevent,conunt:1&#125;&#125; 显示某个国家某个地区的总人数    ])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre class="line-numbers language-none"><code class="language-none">db.集合名.update(&#123;条件 根据这个条件查出对应的数据 字典格式&#125;,&#123;把查到的数据更新成什么 字典格式&#125;,&#123;multi Boolean 如果是true那么就是把查到的所有符合的数据都更新,false的话就只是更新查到的一个符合条件的数据&#125;)    这种方式不是简单的更新,这种属于是替换db.集合名.update(&#123;条件 根据这个条件查出对应的数据 字典格式&#125;,&#123;$set:把查到的数据更新成什么 字典格式&#125;,&#123;multi Boolean 如果是true那么就是把查到的所有符合的数据都更新,false的话就只是更新查到的一个符合条件的数据&#125;)    这种方式就是更新,不会把本不该更新的键值对也替换了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre class="line-numbers language-none"><code class="language-none">db.集合名.remove(&#123;条件 根据这个条件查出对应的数据 字典格式&#125;,&#123;justOne:true&#125;)    justOne表示是否只删除一条,如果是false,那么删除满足条件的所有数据,默认false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre class="line-numbers language-none"><code class="language-none">Object ID: 文档IDString: 字符串,最常用,必须是utf-8Boolean: 存储一个布尔,true或者falseInteger: 整数,可以是32位\64位Double: 浮点数Arrays: 数组或者列表,多个值存入一个键Object: 用于嵌入式的文档,即一个值为一个文档Null: 存储Null值Timestamp: 时间戳,表示从1970-1-1到现在的总秒数Data: 存储当前日期或者时间的UNIX时间格式,在mongodb中可以通过new Date(日期)来使用,存入的是年月日说明:    文档:要存入数据库中的字典,可以是各种嵌套的字典    每一个文档都有一个固定的属性 _id 会自动生成(12字节的十六进制数),多数时间自己设置_id,为了保证唯一性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre class="line-numbers language-none"><code class="language-none">创建索引:    db.collection.ensureIndex(&#123;&quot;索引字段&quot;,排序方式1升序-1降序&#125;,&#123;&quot;索引字段&quot;,&quot;取得名字&quot;&#125;):索引的创建\取名查询索引:    db.collection.getIndexes():查询所有的索引删除索引：    db.collection.dorpIndex(&quot;索引名&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx搭建</title>
      <link href="/2023/01/19/nginx-da-jian/"/>
      <url>/2023/01/19/nginx-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="各种方式安装的nginx的启动方式"><a href="#各种方式安装的nginx的启动方式" class="headerlink" title="各种方式安装的nginx的启动方式"></a>各种方式安装的nginx的启动方式</h2><h3 id="通过命令行安装"><a href="#通过命令行安装" class="headerlink" title="通过命令行安装"></a>通过命令行安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> nginx/etc/init.d/nginx start     <span class="token comment"># 启动</span>/etc/init.d/nginx stop      <span class="token comment"># 停止</span>/etc/init.d/nginx restart   <span class="token comment"># 重启</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过docker安装"><a href="#通过docker安装" class="headerlink" title="通过docker安装"></a>通过docker安装</h3><pre class="line-numbers language-none"><code class="language-none">docker start nginx   # 启动docker stop nginx # 停止docker restart nginx # 重启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="通过编译安装"><a href="#通过编译安装" class="headerlink" title="通过编译安装"></a>通过编译安装</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;xx&#x2F;xx&#x2F;nginx&#x2F;sbin&#x2F;nginx # 启动&#x2F;xx&#x2F;xx&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload # 重启ps -ef | grep nginx &amp;&amp; kill xxxx # 关闭kill -9 nginx # 强制关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nginx概念"><a href="#nginx概念" class="headerlink" title="nginx概念"></a>nginx概念</h2><p>Nginx 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务</p><h3 id="Nginx特色"><a href="#Nginx特色" class="headerlink" title="Nginx特色"></a>Nginx特色</h3><pre class="line-numbers language-none"><code class="language-none">1.反向代理:正向代理：客户端配置代理服务器，通过代理服务器进行互联网访问反向代理：客户端将请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外来说就是一个服务器，暴露得是反向代理服务器的地址，隐藏了真正的服务器地址2、负载均衡（并发性能提升）：在客户端发送多次请求的时候，将请求分发到不同的服务器上3、动静分离：为了提升网站的解析速度，可以将静态页面和动态页面由不同的服务器来解析，加快解析速度，降低原本单个服务器的压力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h3><pre class="line-numbers language-none"><code class="language-none">nginx:安装的本体（nginx.org）依赖：openssl:支持nginx开通https的模块，非对称加密的工具（选择性下载）(https:&#x2F;&#x2F;www.openssl.org&#x2F;）zlib:是一款支持zlib压缩的模块(zlib.net)(必须下载)pcre:是一个支持正则表达式的模块（www.pcre.org）（必须下载）都下载好以后就在usr&#x2F;share&#x2F;下面创建一个nginx文件夹将下载好的文件解压到nginx文件夹下安装C语言编译工具：apt install gccapt install build-essentialapt install make进入解压好的nginx里面：.&#x2F;configure --with-http_ssl_module --with-openssl&#x3D;..&#x2F;opensslx-x-x  --with-pcre&#x3D;..&#x2F;pcrex-x-x --with-zlib&#x3D;..&#x2F;zlibx-x-x这个命令可以将模块加载进入nginx然后用make命令编译一下make install安装一下安装在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;下面进入这个目录启动：    进入sbin执行.&#x2F;nginx重启：    .&#x2F;nginx -s reload关闭：    pkill -9 nginx强制关闭    .&#x2F;nginx -s stop配置：    进入conf，vim编辑nginx.conf配置nginx    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="配置文件：全局块，events块，http块"><a href="#配置文件：全局块，events块，http块" class="headerlink" title="配置文件：全局块，events块，http块"></a>配置文件：全局块，events块，http块</h3><pre class="line-numbers language-none"><code class="language-none">worker_processes  1; # 线程数events &#123;    worker_connections  1024; #最大连接数&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    sendfile        on;    keepalive_timeout  65;    upstream xxx &#123;        # ip_hash # 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。        server 10.0.6.108:7080 weight&#x3D;2; # 权重越大被访问的次数就越多，默认是1，轮询         server 10.0.0.85:8980 weight&#x3D;4;         # fair # 按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。        # 这三种决策使用其中之一就可以          # 这个用于实现负载均衡        # 在location使用：proxy_pass http:&#x2F;&#x2F;xxx就可以    &#125;    server &#123;    listen       80;    server_name  localhost;    # location的一些修饰符：    # &#x3D; 用于精确匹配    # ~ 用于区分大小写的正则匹配，模糊匹配    # ~* 用于不区分大小写的正则匹配，模糊匹配    # ^~ 用于字符串前缀匹配，找到最长匹配（高位匹配最多的，做完美的），然后停止查找    # ^~的优先级大于正则    location ~ &#x2F;group[0-9]&#x2F; &#123;            ngx_fastdfs_module;        &#125;    error_page   500 502 503 504  &#x2F;50x.html;    location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;    &#125;    # server在http中可以有多个    # location在server中也可以有多个，用于解决动静分离的时候可以用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>通过proxy_pass 地址</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ngonx+fdfs搭建</title>
      <link href="/2023/01/19/ngonx-fdfs-da-jian/"/>
      <url>/2023/01/19/ngonx-fdfs-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-FastDfs"><a href="#Nginx-FastDfs" class="headerlink" title="Nginx+FastDfs"></a>Nginx+FastDfs</h2><p><a href="https://github.com/happyfish100">hfdfs项目</a>     fdfs和那llibfastcommon依赖还有fdfs-ngx-module还有nginx链接模块都可以直接克隆相对应仓库</p><h3 id="安装nginx及fastdfs-nginx-module"><a href="#安装nginx及fastdfs-nginx-module" class="headerlink" title="安装nginx及fastdfs-nginx-module"></a>安装nginx及fastdfs-nginx-module</h3><h4 id="解压缩-fastdfs-nginx-module-master-zip"><a href="#解压缩-fastdfs-nginx-module-master-zip" class="headerlink" title="解压缩 fastdfs-nginx-module-master.zip"></a>解压缩 fastdfs-nginx-module-master.zip</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx/ --add-module<span class="token operator">=</span>fastdfs-nginx-module-master解压后的目录的绝对路径/src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="如果nginx还没安装执行"><a href="#如果nginx还没安装执行" class="headerlink" title="如果nginx还没安装执行"></a>如果nginx还没安装执行</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./make<span class="token function">sudo</span> ./make <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --with-http_ssl_module --with-openssl<span class="token operator">=</span><span class="token punctuation">..</span>/openssl-1.1.1m  --with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-8.42 --with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.2.11 <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx/ --add-module<span class="token operator">=</span>/usr/share/fastdfs/fastdfs-nginx-module-master/src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="如果nginx安装了执行"><a href="#如果nginx安装了执行" class="headerlink" title="如果nginx安装了执行"></a>如果nginx安装了执行</h4><blockquote><p>sudo ./make</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> fastdfs-nginx-module-master解压后的目录中src下的mod_fastdfs.conf  /etc/fdfs/mod_fastdfs.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>sudo vim /etc/fdfs/mod_fastdfs.conf</p></blockquote><pre class="line-numbers language-text" data-language="text"><code class="language-text">修改内容：connect_timeout=10tracker_server=自己ubuntu虚拟机的ip地址:22122url_have_group_name=truestore_path0=/home/python/fastdfs/storage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>sudo cp 解压缩的fastdfs-master目录中的http.conf  /etc/fdfs/http.conf</p></blockquote><blockquote><p>sudo cp 解压缩的fastdfs-master目录中的mime.types /etc/fdfs/mime.types</p></blockquote><blockquote><p>sudo vim /usr/local/nginx/conf/nginx.conf</p></blockquote><blockquote><p>在http部分中添加配置信息如下(反向代理)：</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>        listen       <span class="token number">8888</span><span class="token punctuation">;</span>        server_name  localhost<span class="token punctuation">;</span>        location ~/group<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>/ <span class="token punctuation">&#123;</span>            ngx_fastdfs_module<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span>        location <span class="token operator">=</span> /50x.html <span class="token punctuation">&#123;</span>        root   html<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/nginx/sbin/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在换ip之后，storage.conf和client.conf还有mod_fastdfs.cong</p></blockquote><h4 id="python使用fdfs"><a href="#python使用fdfs" class="headerlink" title="python使用fdfs"></a>python使用fdfs</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> fdfs_client-py-master.zip<span class="token operator">>></span><span class="token operator">></span> from fdfs_client.client <span class="token function">import</span> Fdfs_client<span class="token operator">>></span><span class="token operator">></span> client <span class="token operator">=</span> Fdfs_client<span class="token punctuation">(</span><span class="token string">'/etc/fdfs/client.conf'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> client.upload_by_filename<span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#123;&#39;Groupname&#39;:&#39;group1&#39;,&#39;Status&#39;:&#39;Uploadsuccessed.&#39;,&#39;Remotefile_id&#39;:&#39;group1&#x2F;M00&#x2F;00&#x2F;00&#x2F;wKjzh0_xaR63RExnAAAaDqbNk5E1398.py&#39;,&#39;Uploadedsize&#39;:&#39;6.0KB&#39;,&#39;Localfilename&#39;:&#39;test&#39;, &#39;Storage IP&#39;:&#39;192.168.243.133&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fdfs搭建</title>
      <link href="/2023/01/19/fdfs-da-jian/"/>
      <url>/2023/01/19/fdfs-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h2><hr><h3 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h3><h4 id="安装fastdfs依赖包libfastcommon-master"><a href="#安装fastdfs依赖包libfastcommon-master" class="headerlink" title="安装fastdfs依赖包libfastcommon-master"></a>安装fastdfs依赖包libfastcommon-master</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./make.sh<span class="token function">sudo</span> ./make.sh <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="安装fastdfs"><a href="#安装fastdfs" class="headerlink" title="安装fastdfs"></a>安装fastdfs</h4><pre class="line-numbers language-none"><code class="language-none">fastdfs-master目录中.&#x2F;make.shsudo .&#x2F;make.sh install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="配置tracker"><a href="#配置tracker" class="headerlink" title="配置tracker"></a>配置tracker</h4><pre class="line-numbers language-none"><code class="language-none">cp&#x2F;etc&#x2F;fdfs&#x2F;tracker.conf.sample&#x2F;etc&#x2F;fdfs&#x2F;tracker.conf在&#x2F;home&#x2F;python&#x2F;目录中创建目录 fastdfs&#x2F;tracker          mkdir –p &#x2F;home&#x2F;python&#x2F;fastdfs&#x2F;tracker编辑&#x2F;etc&#x2F;fdfs&#x2F;tracker.conf配置文件        sudo vim &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf    修改 base_path&#x3D;xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置storage"><a href="#配置storage" class="headerlink" title="配置storage"></a>配置storage</h4><pre class="line-numbers language-none"><code class="language-none">sudo cp &#x2F;etc&#x2F;fdfs&#x2F;storage.conf.sample &#x2F;etc&#x2F;fdfs&#x2F;storage.conf在&#x2F;home&#x2F;python&#x2F;fastdfs&#x2F; 目录中创建目录 storage    mkdir –p &#x2F;home&#x2F;python&#x2F;fastdfs&#x2F;storage编辑&#x2F;etc&#x2F;fdfs&#x2F;storage.conf配置文件      sudo vim &#x2F;etc&#x2F;fdfs&#x2F;storage.conf修改内容：    base_path&#x3D;&#x2F;home&#x2F;python&#x2F;fastdfs&#x2F;storage    store_path0&#x3D;&#x2F;home&#x2F;python&#x2F;fastdfs&#x2F;storage    tracker_server&#x3D;自己ubuntu虚拟机的ip地址:22122<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置client"><a href="#配置client" class="headerlink" title="配置client"></a>配置client</h4><pre class="line-numbers language-none"><code class="language-none">base_path&#x3D;&#x2F;home&#x2F;python&#x2F;fastdfs&#x2F;trackertracker_server&#x3D;自己ubuntu虚拟机的ip地址:22122<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="上传文件测试"><a href="#上传文件测试" class="headerlink" title="上传文件测试"></a>上传文件测试</h3><pre class="line-numbers language-none"><code class="language-none">fdfs_upload_file &#x2F;etc&#x2F;fdfs&#x2F;client.conf 要上传的图片文件 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask基础</title>
      <link href="/2023/01/19/flask-ji-chu/"/>
      <url>/2023/01/19/flask-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h2 id="name-对象说明"><a href="#name-对象说明" class="headerlink" title="__name__对象说明"></a><code>__name__</code>对象说明</h2><p><code>__name__</code>返回的就是当前的模块名字</p><p><code>__name__</code>如果在本文件中使用的话，那么就是<code>__main__</code></p><p><code>__name__</code>如果本文件被导入到别的文件中使用的话，那么就是模块的名字<br>在文件中，被调用的时候，永远不可能等于<code>__main__</code></p><h2 id="Flask-1"><a href="#Flask-1" class="headerlink" title="Flask"></a>Flask</h2><p>创建Flask对象: 名字 = Flask(一个魔法值(以这个为根目录)),括号里面的参数，就表示以这个参数所在的模块为根目录，默认这个目录中的static为静态目录，templates为模板目录</p><p>创建视图: 等于创建一个函数，要显示给浏览器的数据，直接return</p><p>路径配置: 给视图函数加装饰器,格式: app.route(‘路径’)</p><p>运行flask: app.run(),flask的参数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">,</span>  <span class="token comment"># 创建flask的应用对象，__name__返回的就是当前的模块名字,表示以什么为根目录</span>   static_url_path<span class="token operator">=</span><span class="token string">'/python'</span><span class="token punctuation">,</span>  <span class="token comment"># 访问静态的url前缀，不设置的话默认值是static</span>   static_folder<span class="token operator">=</span><span class="token string">'static'</span><span class="token punctuation">,</span>  <span class="token comment"># 静态文件的目录，默认就是static</span>   template_folder<span class="token operator">=</span><span class="token string">'templates'</span><span class="token punctuation">,</span>  <span class="token comment"># 模板文件的目录，默认的是templates</span>   <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flask的配置"><a href="#flask的配置" class="headerlink" title="flask的配置"></a>flask的配置</h3><blockquote><p>  flask没有Django那种的专门的配置文件，但是可以通过以下的三种方式来配置</p><ul><li>1、使用配置文件:<ul><li>  1、创建一个配置文件xxx.cfg</li><li> 2、app.config.from_pyfile(文件的路径)</li></ul></li><li> 2、使用配置对象:<ul><li>  1、创建一个类，将配置写入</li><li>  2、app.config.from_object(类名)</li></ul></li><li> 3、直接配置    -    app.config[‘DEBUG’] = True<ul><li>  app.config.update(key=v1,k2=v2):一次性配置多个，如果已经存在，那么表示更新</li></ul></li></ul></blockquote><h3 id="获取配置中的参数"><a href="#获取配置中的参数" class="headerlink" title="获取配置中的参数"></a>获取配置中的参数</h3><blockquote><p>   在flask中，配置中除了可以存储flask的配置，也可以存储开发者放的一些数据</p><ul><li>  获取方式一: app.config.get(‘key’)</li><li>   获取方式二: current_app.config.get(‘key’),这是一个模块，也在flask模块中导入，current_app等价于app,有的时候我们拿不到app，所以这个模块可以替代</li></ul></blockquote><h3 id="app-run-的使用"><a href="#app-run-的使用" class="headerlink" title="app.run()的使用"></a>app.run()的使用</h3><blockquote><p>  app.run(host=’x.x.x.x’, port=xxx, debug=True(False)) ,app.run(host=’0.0.0.0’, port=xxx)是万能的</p></blockquote><h3 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h3><blockquote><p> 和Django相比，Flask没有一个直观的路由表，而Django却有urls.py文件可以查看路由表</p><p>  Flask查看路由表: app.url_map，这个方法就可以查看flask的路由表，默认的有static的路由记录，还可以查看请求方式</p><p> 如果某些视图只能用某些请求方式来访问，那么方法就是:@app.route(‘路径’, methods=[请求方式列表])</p><p>  当有多个视图对应同一个url地址的时候，解决方法是：要么修改url,要么修改请求方式</p><p>  当有多个url地址对应一个视图函数的时候(给视图函数多装几个装饰器)，那么就是说这多个url都可以访问这个视图</p><p>  重定向:从flask中导入redirect模块，就可以实现重定向(跳转，两次请求，重定向状态码302),用法:return redirect(url地址)</p><p>  反向解析: 从flask中导入url_for模块,就可以实现反向解析，用法: url = url_for(‘视图函数的名字’, 参数列表)</p></blockquote><h4 id="url带参数"><a href="#url带参数" class="headerlink" title="url带参数"></a>url带参数</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">@app.route('/路径/&lt;转换器类型:参数名>'):    已经实现的转换器类型: int , float , path,如:@app.route('/index/&lt;int:id>'),在访问的时候:127.0.0.1:5000://index/123就可以访问.    不加转换器类型就是表示匹配普通的字符串（除了/）:@app.route('/路径/&lt;参数名>')    int转换器类型，匹配整数    float转换器类型，匹配小数    path转换器类型，匹配字符串，但是包括/        @app.route('/goods/&lt;int:id>')        def goods_detail(id):                '''定义商品视图函数'''            return f'goods detail page&#123;id&#125;'    自定义转换器(三步):        1、定义自己的转换器:            导入from werkzeug.routing import BaseConverter。            定义一个转换器类，使其继承BaseConverter.        2、将自定义的转换器添加到flask的应用中:            app.url_map.converters['转换器名'] = 类名        3、使用:            @app.route('/路径/&lt;转换器类型:参数名>')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义万能转换器"><a href="#定义万能转换器" class="headerlink" title="定义万能转换器"></a>定义万能转换器</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">说明一点:转换器也可以跟参数（re）: @app.route('/路径/&lt;转换器类型(参数):参数名>')方式一、    class ReConverter(BaseConverter):        '''            re万能转换器            创建好自定义的转换器之后，我们就将这个自定义的转换器，添加到应用中            在视图函数使用的时候，可以跟参数，一个正则            工作原理:                在访问网址的时候，给定参数，在服务器接收到数据时，会根据转换器的正则来判断时候是一个非法的数据        '''        # url_map是一个固定的参数,必须调用父类的初始化方法，也必须传入这个参数        def __init__(self, url_map, regex):            super().__init__(url_map)            # self.regex是BaseConverter中的参数（接收正则）,他是专门来看看你自定义的转换器是什么样的一个转换器，接收参数（re）            # 将正则表达式的参数保存到对象的属性中，flask会去使用这个属性来进行正则匹配            self.regex = regex    # 加到应用中    app.url_map.converters['re'] = ReConverter    @app.route("/goods/&lt;re(r'1[34578]\d&#123;9&#125;'):id>")    def goods_detail(id):        '''定义商品视图函数'''        return f'goods detail page&#123;id&#125;'方式二、    class ReConverter(BaseConverter):        '''            re万能转换器            创建好自定义的转换器之后，我们就将这个自定义的转换器，添加到应用中            在视图函数使用的时候，可以跟参数，一个正则            工作原理:                在访问网址的时候，给定参数，在服务器接收到数据时，会根据转换器的正则来判断时候是一个非法的数据        '''        # url_map是一个固定的参数,必须调用父类的初始化方法，也必须传入这个参数        def __init__(self, url_map):            super().__init__(url_map)            # self.regex是BaseConverter中的参数（接收正则）,他是专门来看看你自定义的转换器是什么样的一个转换器，接收参数（re）            # 将正则表达式的参数保存到对象的属性中，flask会去使用这个属性来进行正则匹配            self.regex = r'1[34578]\d&#123;9&#125;'    # 加到应用中    app.url_map.converters['re'] = ReConverter    @app.route("/goods/&lt;re:id>")    def goods_detail(id):        '''定义商品视图函数'''        return f'goods detail page&#123;id&#125;'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级的转换器应用"><a href="#高级的转换器应用" class="headerlink" title="高级的转换器应用"></a>高级的转换器应用</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">class ReConverter(BaseConverter):    '''        re万能转换器        创建好自定义的转换器之后，我们就将这个自定义的转换器，添加到应用中        在视图函数使用的时候，可以跟参数，一个正则        工作原理:            在访问网址的时候，给定参数，在服务器接收到数据时，会根据转换器的正则来判断时候是一个非法的数据    '''    # url_map是一个固定的参数,必须调用父类的初始化方法，也必须传入这个参数    def __init__(self, url_map):        super().__init__(url_map)        # self.regex是BaseConverter中的参数（接收正则）,他是专门来看看你自定义的转换器是什么样的一个转换器，接收参数（re）        # 将正则表达式的参数保存到对象的属性中，flask会去使用这个属性来进行正则匹配        self.regex = r'1[34578]\d&#123;9&#125;'    '''        to_python和to_url都是父类中的方法:            to_python:在匹配成功以后，请求网址带来的参数会交给to_python做出处理，返回的结果为视图函数的参数            to_url:在使用重定向(url_for)的时候使用，url("视图名",参数)            使用重定向的时候，被定向的视图函数如果有参数需要匹配，那么，在重定向的时候，在使用url_for()的时候，就会去匹配一次被定向视图使用的转换器，在匹配成功的同时调用to_url方法            在to_url中处理以后，会交给to_python处理    '''    def to_python(self, value):        return value    def to_url(self, value):        return '13443218888'# 加到应用中app.url_map.converters['re'] = ReConverter@app.route("/goods/&lt;re:id>")def goods_detail(id):    '''定义商品视图函数'''    return f'goods detail page&#123;id&#125;'@app.route("/index")def index():    url = url_for("goods_detail", id=13412344321)    return redirect(url)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">从flask中导入request和Responserequest中常用的属性:    data:获取请求的数据，并转换为字符串，request.data    form:获取请求中的表单数据,request.form.get()，获取一对一,request.form.getlist()，获取一对多的数据    args:获取url中的参数(http:x.x.x.x:xxx/xxx?city=chengdu)，    cookies:获取到cookie，request.cookies.get()    headers:获取请求头中的报文:request.headers    method:获取请求方式:request.method    url:获取请求的url:request.url    files:获取上传的文件:  if request.method == 'POST':                            file = request.files.get('pic')                            file.save(f'./img/&#123;file.filename&#125;')    path: 拿到浏览器请求的地址（视图）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><pre class="line-numbers language-none"><code class="language-none">从flask中导入abort无条件终止视图函数的执行，并返回给前端特定的信息用法一、    abort（状态码）用法二、    re &#x3D; Response(&quot;login defete&quot;)    abort(re)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><pre class="line-numbers language-none"><code class="language-none">用户访问的页面不错在的时候，定义一个独立的视图,用@app.errorheader(404)来装饰固定写法:    @app.errorhandler(404)    def header_error(err):         return &#39;没有&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置响应信息的方法"><a href="#设置响应信息的方法" class="headerlink" title="设置响应信息的方法"></a>设置响应信息的方法</h3><pre class="line-numbers language-none"><code class="language-none">从flask中导入make_response方法一:    使用:    rsp &#x3D; make_response(显示的字符串)    rsp.status &#x3D; &#39;999 lqs&#39;  状态码    rsp.headers[&#39;lqs&#39;] &#x3D; &#39;lqs&#39;   头信息    return rsp方法二:    return 显示字符串, 状态码, 头信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><pre class="line-numbers language-none"><code class="language-none">方法一、import json    dic &#x3D; &#123;&quot;name&quot;: &quot;lqs&quot;, &quot;age&quot;: 12&#125;    json_str &#x3D; json.dumps(dic)    print(type(json_str))    print(json_str)    dic_str &#x3D; json.loads(json_str)    print(type(dic_str))    print(dic_str)json.dumps():字典转json字符串json.loads():json字符串转字典方法二、从flask中导入jsonify    return jsonify(dic) ：将字典转成json字符串，并且自动设置头信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cookie的读写"><a href="#cookie的读写" class="headerlink" title="cookie的读写"></a>cookie的读写</h3><pre class="line-numbers language-none"><code class="language-none">读写和django一样，都是通过response写入，通过request读取在有关cookie的操作中，都要 app.config[&quot;SECRET_KEY&quot;] &#x3D; xxxxxx    导入:from flask import make_response    实例化:resp &#x3D; make_response(显示字符串)    设置:resp.set_cookie(&quot;lqs&quot;, &quot;Flask&quot;, max_age&#x3D;3600)    读取:request.cookies.get(&#39;lqs&#39;)    删除:resp.delete_cookie(&#39;lqs&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="session的读写"><a href="#session的读写" class="headerlink" title="session的读写"></a>session的读写</h3><pre class="line-numbers language-none"><code class="language-none">导入: from flask import session设置: session[key] &#x3D; value读取: session.get(key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><pre class="line-numbers language-none"><code class="language-none">类似于django中的中间件在请求的时候使用，不是任何请求都会调用，是调用到视图函数的时候，在之前或者之后进行操作@app.before_first_request : 第一次请求之前调用@app.before_request : 每次请求之前调用@app.after_request : 每次请求之后调用（视图函数没有出错的情况）@app.teardown_request : 每次请求之后调用（不论是否出错都会调用）@app.after_request : 对应的视图函数必须带一个参数，用来接收视图函数的返回值，也就是接收在页面上现实的东西@app.teardown_request : 对应的视图函数必须带一个参数，用来接收视图函数的返回值，也就是接收在页面上现实的东西<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="g对象"><a href="#g对象" class="headerlink" title="g对象"></a>g对象</h3><pre class="line-numbers language-none"><code class="language-none">from flask import gg对象中保存的数据，在一次请求中的，多个函数中可以使用使用:    g.key &#x3D; value:存    xx &#x3D; g.key:取<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flask-script扩展-实现shell代码-这样子可以和django一样，runserver"><a href="#flask-script扩展-实现shell代码-这样子可以和django一样，runserver" class="headerlink" title="flask_script扩展(实现shell代码),这样子可以和django一样，runserver"></a>flask_script扩展(实现shell代码),这样子可以和django一样，runserver</h3><pre class="line-numbers language-none"><code class="language-none">pip install Flask-Scriptfrom flask_script import Managermanager &#x3D; Manager(flask应用名)manager.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flask使用模板文件"><a href="#flask使用模板文件" class="headerlink" title="flask使用模板文件"></a>flask使用模板文件</h3><pre class="line-numbers language-none"><code class="language-none">from flask import render_templatereturn render_template(&quot;html模板&quot;, key&#x3D;value, key&#x3D;value)  或者    return render_template(&quot;html模板&quot;, **字典名（组织之后的上下文）)在html模板文件中，可以使用过滤器:使用方法:&#123;&#123;value | 过滤器&#125;&#125;如safe就表示转义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="flask中html模板转义"><a href="#flask中html模板转义" class="headerlink" title="flask中html模板转义"></a>flask中html模板转义</h3><pre class="line-numbers language-none"><code class="language-none">使用方法: &#123;&#123; 处理对象 | 过滤器 &#125;&#125;常用过滤器:    safe : 禁用转义    capitalize : 变量值的首字母转换成大写其余小写    lower : 全部转换为小写    upper : 全部转换为大写    title : 每个单词首字母大写    trim  : 去除首尾空格    reverse : 字符串反转    format : 格式化输出    striptags : 渲染之前把所有的html标签去掉    first : 取出列表中的第一个元素    last : 取出列表中的最后一个元素    length : 获取列表的长度    sum : 列表数据求和    sort : 列表排序自定义过滤器:    在flask代码中定义    第一种方式(函数):        定义一个过滤器函数        返回值就是过滤后的数据        app.add_template_filter(函数名, 过滤器名)就可以注册这个过滤器        然后在html模板中使用    第二种方式(装饰器:        定义一个过滤器函数        返回值就是过滤后的数据        加装饰器:@app.template_filter(过滤器名)        然后在html模板中使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flask使用Flask-WTF"><a href="#flask使用Flask-WTF" class="headerlink" title="flask使用Flask-WTF"></a>flask使用Flask-WTF</h3><pre class="line-numbers language-none"><code class="language-none">可以在服务器端(创建表单模型)校验表单数据，可以设置csrf攻击的关闭pip install Flask-WTFfrom flask_wtf import FlaskForm : 这个模块让类继承之后就可以实现创建表单模型from wtforms import StringField, PasswordField, SubmitField : 这个wtforms模块中的方法都是关于表单中的各个控件的类型，这里没有写全面from wtforms.validators import DataRequired, EqualTo : wtforms下面的validators模块中的方法就是一些校验规则说明: 在flask中定义的表单模型作用有两个,首先，第一个作用就是不用用户再去自己打表单，可以将表单模型传到模板中生成表单，第二个作用就是验证数据，两个作用是区分开的定义表单模型类:    class LoginForm(FlaskForm):    &#39;&#39;&#39;        自定义的注册表单抽象类            label标签表示设置名称,用中文就使用u&quot;xx&quot;            validators表示验证数据，是一个列表类型            DataRequired表示必须输入，有一个参数，表示验证失败的时候显示文本            EqualTo表示和谁一样，有连个参数，第一个填写和谁一样，第二个填写验证失败的显示文本    &#39;&#39;&#39;        user_name &#x3D; StringField(label&#x3D;u&quot;用户名&quot;, validators&#x3D;[DataRequired(&quot;用户名不能为空&quot;)])        password &#x3D; PasswordField(label&#x3D;r&quot;密码&quot;, validators&#x3D;[DataRequired(&quot;密码不能为空&quot;)])        password2 &#x3D; PasswordField(label&#x3D;r&quot;确认密码&quot;, validators&#x3D;[DataRequired(&quot;确认密码不能为空&quot;), EqualTo(&quot;password&quot;, &quot;两次密码不一致&quot;)])        submit &#x3D; SubmitField(label&#x3D;u&quot;提交&quot;)        @app.route(&quot;&#x2F;login&quot;, methods&#x3D;[&quot;POST&quot;, &quot;GET&quot;])        def login():            &#39;&#39;&#39;创建表单对象&#39;&#39;&#39;            form &#x3D; LoginForm()            # 判断form中的数据是否合理            # 如果form中的数据完全满足验证，则返回真，否则返回假            if form.validate_on_submit():                uname &#x3D; form.user_name.data                pwd &#x3D; form.password.data                pwd2 &#x3D; form.password2.data                print(uname, pwd, pwd2)                session[&quot;username&quot;] &#x3D; uname                url &#x3D; url_for(&quot;index&quot;)                return redirect(url)            return render_template(&quot;login.html&quot;, form&#x3D;form)在html模板中生成表单:     &lt;form  method&#x3D;&quot;post&quot;&gt;        &#123;&#123; form.csrf_token&#125;&#125;        &#123;&#123; form.user_name.label &#125;&#125; &#123;&#123; form.user_name &#125;&#125;&lt;br&gt;        &#123;% for msg in form.user_name.errors %&#125;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;p&gt;        &#123;% endfor %&#125;        &#123;&#123; form.password.label &#125;&#125; &#123;&#123; form.password &#125;&#125;&lt;br&gt;        &#123;% for msg in form.password.errors %&#125;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;p&gt;        &#123;% endfor %&#125;        &#123;&#123; form.password2.label &#125;&#125; &#123;&#123; form.password2 &#125;&#125;&lt;br&gt;        &#123;% for msg in form.password2.errors %&#125;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;p&gt;        &#123;% endfor %&#125;        &lt;p&gt;&#123;&#123; form.submit &#125;&#125;&lt;&#x2F;p&gt;     &lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="宏的定义和使用"><a href="#宏的定义和使用" class="headerlink" title="宏的定义和使用"></a>宏的定义和使用</h3><pre class="line-numbers language-none"><code class="language-none">在同一个html中定义和使用:    没有参数:        定义:        &#123;% macro input() %&#125;         &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;&quot; value&#x3D;&quot;&quot; size&#x3D;&quot;30&quot;&gt;        &#123;% endmacro %&#125;        使用:        &#123;&#123; input() &#125;&#125;    有参数:    定义:    &#123;% macro input(type,name,size) %&#125;     &lt;input type&#x3D;&#123;&#123;type&#125;&#125; name&#x3D;&#123;&#123;name&#125;&#125; value&#x3D;&quot;&quot; size&#x3D;&#123;&#123;size&#125;&#125;&gt;    &#123;% endmacro %&#125;    使用:    &#123;&#123; input(&#39;text&#39;, &#39;username&#39;, 40) &#125;&#125;在不同html中定义和使用:    没有参数:        定义在macro2.html中:        &#123;% macro input() %&#125;         &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;&quot; value&#x3D;&quot;&quot; size&#x3D;&quot;30&quot;&gt;        &#123;% endmacro %&#125;        在macro。html使用:        &#123;% import &quot;macro2.html&quot; as 别名 %&#125;        &#123;&#123; 别名.input() &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><pre class="line-numbers language-none"><code class="language-none">和django中的模板继承一样: &#123;% extend &quot;模板名&quot; %&#125;  使用 &#123;% block xx %&#125; &#123;% endblock xx %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="flask中一些特殊的方法"><a href="#flask中一些特殊的方法" class="headerlink" title="flask中一些特殊的方法"></a>flask中一些特殊的方法</h3><pre class="line-numbers language-none"><code class="language-none">有些方法和变量不需要传递也可以在模板中直接使用config中的方法request中的方法url_for中的方法模板的闪现:    闪现就是表示有的信息，只是出现一次    在flask中:from flask import flash            在视图中使用flash(xxx)来添加信息，可以添加很多条    在模板中:        &#123;% for x in get_flashed_messages() %&#125;        &#123;&#123; x &#125;&#125;        &#123;% endfor %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flask链接数据库"><a href="#flask链接数据库" class="headerlink" title="flask链接数据库"></a>flask链接数据库</h3><pre class="line-numbers language-none"><code class="language-none">pip install flask-sqlalchemy  模型类到sql语句的转换，再将结果转换为模型类对象pip install flask-mysqldb   数据库驱动from flask_sqlalchemy import SQLAlchemy  可以创建数据库对象配置:    app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] &#x3D; &quot;mysql:&#x2F;&#x2F;root:123456@127.0.0.1:3306&#x2F;msfood&quot;    app.config[&#39;SQLALCHEMY_TRACK_MODIFICATIONS&#39;] &#x3D; True   # 配置跟踪,数据库和模型类同步创建数据库sqlalchemy工具对象,就可以使用数据库了    db &#x3D; SQLAlchemy(app)创建模型类class Role(db.Model):    &#39;&#39;&#39;身份表&#39;&#39;&#39;    __tablename__ &#x3D; &quot;tbl_roles&quot;  # 指明表名    id &#x3D; db.Column(db.Integer, primary_key&#x3D;True)    name &#x3D; db.Column(db.String(32), unique&#x3D;True)    users &#x3D; db.relationship(&quot;User&quot;, backref&#x3D;&quot;role&quot;)     def __repr__(self):        &#39;&#39;&#39;补充方法,可以让显示对象的时候更直观,类似于__str__方法&#39;&#39;&#39;        return f&#39;&#123;self.users&#125;&#39;class User(db.Model):    &#39;&#39;&#39;用户表&#39;&#39;&#39;    __tablename__ &#x3D; &quot;tbl_users&quot;  # 指明数据库的表名    id &#x3D; db.Column(db.Integer, primary_key&#x3D;True)  # 主键，自动递增    name &#x3D; db.Column(db.String(64), unique&#x3D;True)    email &#x3D; db.Column(db.String(128), unique&#x3D;True)    password &#x3D; db.Column(db.String(128))    role_id &#x3D; db.Column(db.Integer, db.ForeignKey(&quot;tbl_roles.id&quot;))生成数据表:    *第一次生成的时候清除所有数据:         db.drop_all()    创建所有表        db.create_all()说明:    创建表的时候，和底层相关，只要是表中的一行，都是有关底层的，用的都是真实的表的名字    users &#x3D; db.relationship(&quot;User&quot;, backref&#x3D;&quot;role&quot;): 这个语句就是表示和底层无关，只和flask中的对象有关，User就是一个模型对象        users表和roles表是有关联的（外键）,那么db.relationship就可以让两个表相互拿东西，表示从User模型类中拿出和Role模型有关联的数据        backref表示没有定义relationship的对方表中，也可以反推拿出和User模型有关的Role模型的数据        使用方法:            在Role模型:role.users            在user模型中:user.role添加数据:    创建对象:xx &#x3D; 模型(属性&#x3D;值，属性&#x3D;值)    session记录对象任务:db.session.add(xx),添加一条数据，db.session.add_all(),添加多条数据    提交任务到数据库:db.session.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sqlalchemy查询"><a href="#sqlalchemy查询" class="headerlink" title="sqlalchemy查询"></a>sqlalchemy查询</h3><pre class="line-numbers language-none"><code class="language-none">用模型类来查询模型类.query.all():查询所有数据，返回的是一个列表，可以取出某一个对象，然后读取属性值模型类.query.first():返回第一条记录模型类.query.get(主键的id):根据主键id获取对象模型类.query.filter_by(字段&#x3D;xx,字段&#x3D;&#x3D;xx).all():获取满足条件的所有数据,条件是与模型类.query.filter(模型类.字段&#x3D;&#x3D;xx,模型类.字段&#x3D;&#x3D;xx).all():拿出满足条件的所有数据，条件是与模型类.query.filter(or_(模型类.字段&#x3D;&#x3D;xx,模型类.字段.endswith(xxx))).all():拿出满足条件的所有数据，条件是或，使用或必须导入from sqlalchemy import or_模型类.query.filter(条件).offset(2).limit(3).order_by(模型类.字段.desc()).all():返回满足条件并且忽略前两条数据，取出三条数据然后降序排列的数据，每一个部分都可以单独使用db.session.query(模型类.字段, func.count(模型类.字段)).group_by(模型类.字段).all():分组查询，from sqlalchemy import func,func.聚合函数(属性),就可以查出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sqlalchemy修改"><a href="#sqlalchemy修改" class="headerlink" title="sqlalchemy修改"></a>sqlalchemy修改</h4><pre class="line-numbers language-none"><code class="language-none">模型类.query.filter(条件).update(&#123;字段名:值,字段名:值,字段名:值&#125;)db.session.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="sqlalchemy删除"><a href="#sqlalchemy删除" class="headerlink" title="sqlalchemy删除"></a>sqlalchemy删除</h4><pre class="line-numbers language-none"><code class="language-none">xx &#x3D; 模型类.query.get(x)db.session.delete(xx)db.session.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="flask中和django一样使用迁移的方式"><a href="#flask中和django一样使用迁移的方式" class="headerlink" title="flask中和django一样使用迁移的方式"></a>flask中和django一样使用迁移的方式</h4><pre class="line-numbers language-none"><code class="language-none">pip install flask-migratefrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommanddb &#x3D; SQLAlchemy(app)创建flask脚本管理工具manager &#x3D; Manager(app)创建数据库迁移工具对象Migrate(app, db)向manager对象中添加数据的操作命令manager.add_command(&quot;操作的名字&quot;, MigrateCommand)main中:    manager.run()终端中:    python3 xxx.py 操作的名字 init  : 让他初始化一下，自动创文件夹    python3 xxx.py 操作的名字 migrate -m &quot;版本说明信息&quot; : 生成迁移文件（版本说明可以不要），同价与django中的makemigrations    多次migrate之后需要更新数据库:python3 xxx.py 操作的名字 upgrade，可以升级同步    python3 xxx.py 操作的名字 history : 查看历史修改    python3 xxx.py 操作的名字 downgrade 版本编号 : 版本回退<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flask发送邮件"><a href="#flask发送邮件" class="headerlink" title="flask发送邮件"></a>flask发送邮件</h3><pre class="line-numbers language-none"><code class="language-none">pip install flask-mailfrom flask_mail import Mail, Messageapp &#x3D; Flask(__name__)app.config.update(    DEBUG&#x3D;True,    MAIL_SERVER&#x3D;&#39;smtp.qq.com&#39;,    MAIL_PROT&#x3D;465,    MAIL_USE_TLS&#x3D;True,    MAIL_USERNAME&#x3D;&#39;749062870@qq.com&#39;,    MAIL_PASSWORD&#x3D;&#39;kttumcufpqasbcii&#39;,) # sender发送方,recipients接收方列表    mail &#x3D; Mail() : 创建mail对象    mail.init_app(app) : 初始化mail对象    msg &#x3D; Message(&quot;傻逼&quot;, sender&#x3D;&quot;749062870@qq.com&quot;, recipients&#x3D;[&quot;2807175480@qq.com&quot;]) : 设置邮件消息的邮件头    msg.body &#x3D; &quot;傻逼&quot;  : 设置邮件的正文    mail.send(msg) : 发送邮件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="蓝图（Blueprint）"><a href="#蓝图（Blueprint）" class="headerlink" title="蓝图（Blueprint）"></a>蓝图（Blueprint）</h3><pre class="line-numbers language-none"><code class="language-none">之前写的都在一个py文件中蓝图就是分割各个块将视图写在其他的py文件中，那么不用再给写在外面的视图加装饰器，可以在有app的py文件中导入，然后通过app.route(&quot;路径&quot;)(视图函数)蓝图的正解:    &#39;&#39;&#39;        蓝图和django中的各个应用差不多,一个蓝图自成一块，在主窗口中注册进app里面就可以使用        使用方法:            创建一个应用目录，再添加一个__init__.py让这个目录成为一个可以调动的包，再__init__.py中定义好蓝图,再到视图中导入这个蓝图，就可以使用，最后再视图使用之后，再到__init__.py中            导入视图中使用了蓝图的视图函数。            蓝图再使用模板文件和静态文件的时候，和主app不同，主app有默认的配置，而蓝图中没有，需要再定义蓝图的时候手动设置，和主app的设置方法是一样的            蓝图在没有定义静态文件目录和模板文件目录的时候，默认是使用主app的，就算配置可静态目录和模板目录，蓝图也是先去主app的静态目录和模板目录查找，没有找到在回到自己的里面去找，这个时候，就是主app的优先级大于蓝图            在视图中使用蓝图:                1、在__init__.py中from flask import Blueprint                2、在__init__.py中定义蓝图,xx &#x3D; Blueprint(&quot;蓝图名&quot;,__name__)                3、导入蓝图                4、用蓝图装饰，和主app装饰视图一摸一样的                5、在__init__.py中导入使用了蓝图的视图函数（导入到蓝图之下）                6、在主app的文件中注册蓝图:app.register_blueprint(蓝图, url_prefix&#x3D;&quot;&#x2F;lqs&quot;)，url_prefix表示前缀    &#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre class="line-numbers language-none"><code class="language-none">在flask中使用单元测试的时候，千万不要动源代码，重新写个测试文件import unittest导入要测试的flask代码文件创建测试类，继承unittest.TestCase定义好测试函数import unittestimport jsonfrom flaskDay14 import Testclass Index(unittest.TestCase):    def setUp(self):        # 设置flask工作在测试模式下，在测试出错的时候会给出具体错误行        Test.app.testing &#x3D; True        # 模拟flask客户端,setUp中的代码会在所有函数之前调用        self.client &#x3D; Test.app.test_client()    def test_index(self):        # 模拟请求返回数据        ret &#x3D; self.client.post(&quot;&#x2F;index&quot;, data&#x3D;&#123;&quot;username&quot;:&quot;lqs&quot;, &quot;password&quot;:&quot;lqs&quot;&#125;)        # 拿到数据        resp &#x3D; ret.data        # 装成字典        resp &#x3D; json.loads(resp)        # 断言        self.assertIn(&quot;code&quot;, resp)        self.assertEqual(resp[&quot;code&quot;], 2)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # 测试    unittest.main()对所有的测试都可以使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础</title>
      <link href="/2023/01/19/django-ji-chu/"/>
      <url>/2023/01/19/django-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>django-admin startproject 项目名</p><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>python manage.py startapp 应用名</p><h3 id="运行web服务器"><a href="#运行web服务器" class="headerlink" title="运行web服务器"></a>运行web服务器</h3><p>python manage.py runserver</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python3 <span class="token operator">-</span>m http<span class="token punctuation">.</span>server <span class="token punctuation">[</span>port<span class="token punctuation">]</span> <span class="token comment"># 可以启动一个web服务，供局域网内用户下载文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="将固定的路径加入python可以搜索的目录"><a href="#将固定的路径加入python可以搜索的目录" class="headerlink" title="将固定的路径加入python可以搜索的目录"></a>将固定的路径加入python可以搜索的目录</h3><p>import sys</p><p>sys.path.insert(位置（从0开始），要加入搜索的目录)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python manage<span class="token punctuation">.</span>py shell <span class="token comment"># 进入django终端</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><ul><li>   1、对象和数据库映射</li><li>   2、根据设计的模型生成数据库中的表:    -  1、生长牵引文件:python manage.py makemigrations    - 2、执行牵引文件:python manage.py migrate</li></ul><h3 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h3><blockquote><p>在models.py中编写模型类</p></blockquote><ul><li> 1、生长迁移文件:python manage.py makemigrations    -    注意如果有ForeignKey的话一定要加上on_delete = models.CASCADE</li><li>2、执行迁移文件:python manage.py migrate</li></ul><blockquote><p>python manage.py shell</p></blockquote><pre class="line-numbers language-text" data-language="text"><code class="language-text">首先:导入定义好的模型类其次:实例化一个对象插入 :对象.属性名=值保存:对像.save()拿到数据:变量 = 类名.objects.get(条件)    变量.属性：直接查看    变量.属性=值  ——> 变量.save()  :修改    变量.delete():删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后台管理（在admin-py中编写后台管理类）"><a href="#后台管理（在admin-py中编写后台管理类）" class="headerlink" title="后台管理（在admin.py中编写后台管理类）"></a>后台管理（在admin.py中编写后台管理类）</h3><pre class="line-numbers language-none"><code class="language-none">本地化: LANGUAGE_CODE &#x3D; &#39;zh-hans&#39; :使用中文       TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39; :使用中国时间创建管理员:python manage.py createsuperuser   (第一次新建管理员的时候必须要执行一下牵引文件，可以不生成，但必须执行)自己创建的管理员是默认是放在数据库中的一个单独的表中的，但是可以使用（在settings.py中）：# django认证系统使用的模型类AUTH_USER_MODEL&#x3D;&#39;应用.类名&#39;这个来规定生成数据放在什么表，在实际开发中是特别的重要的，一般和用户信息放在一起使用这个必须导入(models.py中)from django.contrib.auth.models import AbstractUser加入自己定义的数据库或者数据库模型: 1、导入 2、admin.site.register(类)规定自定义的数据库或者数据库模型的显示: list_display(&#39;&#39;,&#39;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用视图（在views中编写）"><a href="#使用视图（在views中编写）" class="headerlink" title="使用视图（在views中编写）"></a>使用视图（在views中编写）</h3><pre class="line-numbers language-none"><code class="language-none">使用模块: from django.http import HttpResponse,HttpResponseRedirect(重定向)使用模块: from django.shortcuts import render,redirect(也是重定向)使用 return HttpResponse(&#39;返回值&#39;) 返回结果使用模块: from django.conf.urls import include, urlurl的使用方法:url(r&#39;正则表达式&#39;,处理字符串)            url(r&#39;正则表达式&#39;,include(处理源))实现过程: views.py 中创建视图（使用模块第一个） ---&gt;  创建 urls.py (使用第二个模块,并且导入views.py)  ---&gt;  项目中的urls.py中添加创建的urls.py(使用url添加)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板（项目文件夹中创建-模板文件夹templates）"><a href="#模板（项目文件夹中创建-模板文件夹templates）" class="headerlink" title="模板（项目文件夹中创建 模板文件夹templates）"></a>模板（项目文件夹中创建 模板文件夹templates）</h3><pre class="line-numbers language-none"><code class="language-none">在项目文件夹中的setting中设置TEMPLATES中的DIRS，表示模板位置，一般拼接使用模板:    导入模块:from django.template import loader    1、使用模板文件: temp &#x3D; loader.get_template(&#39;文件名可以带路径&#39;)    2、定义上下文（个模板传参数）: context &#x3D; &#123;字典参数&#125;    3、渲染模板:产生HTML代码:res_html &#x3D; temp.render(context)    4、返回浏览器:return HttpResponse(res_html)最简单的使用方法: return render(request,&#39;文件可以带路径&#39;,&#123;传参数&#125;)参数在html代码中的使用方法:    普通变量:&#123;&#123;key&#125;&#125;    for循环:&#123;% fro x in xx %&#125;            &#123;%endfor%&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于django和数据库的操作"><a href="#关于django和数据库的操作" class="headerlink" title="关于django和数据库的操作"></a>关于django和数据库的操作</h2><pre class="line-numbers language-none"><code class="language-none">1、创models文件 class xxx(models.Model)2、迁移文件3、创建views文件 def xxx(request)，必须有返回值,一般返回值用HttpResponse,使用模板的返回值用render,需要重定向的话使用redirect4、新建应用urls.py文件,用于定义访问时用的url地址5、取项目中的urls文件中添加应用的url文件 ：url(r&#39;^&#39;,include(xxx.urls))6、在项目中创建templates模板文件,在到seting中配置一下，templates中的文件就是html文档<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一大点-models-模型-注册模型类"><a href="#第一大点-models-模型-注册模型类" class="headerlink" title="第一大点:models,模型,注册模型类"></a>第一大点:models,模型,注册模型类</h3><p>django操作数据库的相关知识</p><pre class="line-numbers language-none"><code class="language-none">应用下的models.py文件中定义的所有模型，都要继承一个抽象基类:创建抽象基类:在项目中创建一个pythonPakage,名字叫db,在这个包下面创建一个base_model.py文件，在文件中编写一个抽像基类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">class</span> <span class="token class-name">BaseModel</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''模型抽象基类'''</span>        create_time <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now_add<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> verbose_name<span class="token operator">=</span><span class="token string">'创建时间'</span><span class="token punctuation">)</span>    update_time <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>auto_now<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> verbose_name<span class="token operator">=</span><span class="token string">'更新时间'</span><span class="token punctuation">)</span>        is_delete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> verbose_name<span class="token operator">=</span><span class="token string">'删除标记'</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''说明是一个抽象模型类'''</span>        abstract <span class="token operator">=</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="约束选项在字段类型中使用，字段类型在models模块下使用"><a href="#约束选项在字段类型中使用，字段类型在models模块下使用" class="headerlink" title="约束选项在字段类型中使用，字段类型在models模块下使用"></a>约束选项在字段类型中使用，字段类型在models模块下使用</h5><p>字段类型:</p><pre class="line-numbers language-none"><code class="language-none">1、AutoField:自动编号2、BooleanField:布尔类型3、NullBooleanField:Null，True，False三种值4、CharField（max_length&#x3D;）:字符串,必须指定max_length5、TextField:大文本类型6、IntegerField:整数7、DecimalField(max_digits&#x3D;,decimal_places&#x3D;):浮点数，第一个参数表示总位数，第二个参数表示小数位数8、FloatField(max_digits&#x3D;,decimal_places&#x3D;):浮点数，参数同上9、DateField（[auto_now&#x3D;,auto_now_add&#x3D;]）:日期类型，有两个可选参数，用的时候只能用一个，第一个表示更新时间，第二个表示第一次创建的的时间10、TimeField（[auto_now&#x3D;,auto_now_add&#x3D;]）:时分秒11、DateTimeField（[auto_now&#x3D;,auto_now_add&#x3D;]）:年月日时分秒12、FileField:文件上传13、ImageField:有效图片14、ForeignKey:一对多15、ManyToManyField:多对多16、OneToOneField:一对一约束选项:1、default:默认值2、primary_key:主键3、unique:不重复4、db_index:索引，db_index&#x3D;True&#x2F;False5、db_column:指定表字段的名字，db_column&#x3D;&#39;名字&#39;6、null:空7、blank:是否为空，在后台使用，默认True，在django管理页面有用8、chioces：chioces选项,等于一个元组，格式 choices &#x3D; ((xx,xxx),(xx,xxx)……),网页显示为一个列表框9、verbose_name：制定在后台的显示名称 ，字段和表名都可以用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h4><pre class="line-numbers language-none"><code class="language-none">django使用tinymce：    pip install django-tinymce    from tinymce.models import HTMLField    xx &#x3D; HTMLField(verbose_name &#x3D; &#39;xx&#39;)    在settings.py中注册这个富文本编辑器，INSTALLED_APPS中添加tinymce    在settings.py中设置富文本编辑器的属性：        TINYMCE_DEFAULT_CONFIG &#x3D; &#123;            &#39;theme&#39;: &#39;advanced&#39;,            &#39;width&#39;: 编辑器的宽,            &#39;height&#39;: 编辑器的高,        &#125;    在项目urls中添加: url(r&#39;^tinymce&#x2F;&#39;, include(&#39;tinymce.urls&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre class="line-numbers language-none"><code class="language-none">说明一下:exclude,filter,get三个都时带条件的---&gt;模型名.objects.查询方式(属性名__条件名&#x3D;值)条件名:exact:判等 ，可以不用直接用 &#x3D;contains:模糊查询，包含endswith\startswith:模糊查询，结尾\开头isnull:空查询,布尔值in:范围查询，属性名__in &#x3D; 列表或者元组gt,lt,gte,lte:大于，小于，大于等于，小于等于day&#x2F;month&#x2F;year:使用方法:日期查询get():返回满足条件的一条记录all():返回所有记录，查询集filter():返回满足条件的所有记录，查询集exclude():返回不满足条件的所有记录，查询集order_by(‘属性名1’,’属性名2&#39;……):升序order_by(‘-属性名1’,’-属性名2&#39;……):降序，order_by()是将查出来的数据进行排序，如：BookInfo.objects.all().order_by(&#39;id&#39;,&#39;-btitle&#39;)Q对象:用于查询时候的多个条件的  ’与或非‘  表示    from django.db.models import Q    例子:        BookInfo.object.filter(Q(id &#x3D; 2) &amp; Q(btitle &#x3D; &#39;hello&#39;))   与        BookInfo.object.filter(Q(id &#x3D; 2) | Q(btitle &#x3D; &#39;hello&#39;))   或        BookInfo.object.filter(~Q(id &#x3D; 2))                        非F对象:条件中用于属性比较,还可以进行算数运算    from django.db.models import F    例子:        BookInfo.objects.filter(id__gt &#x3D; F(&#39;bid&#39;))        BookInfo.objects.filter(id__gt &#x3D; F(&#39;bid&#39;)*3)聚合函数:sum,count,avg,max,min,在django中通过aggregates来使用    from django.db.models import Sum,Count,Avg,Max,Min    例子:        BookInfo.objects.all().aggregate(Count(&#39;id&#39;)) : 返回值是字典        BookInfo.objects.all().aggregate(Sum(&#39;bread&#39;) : 总和插入、更新、删除:    save():插入更新    delete():删除关联查询:    一对多:对象.多类的名字__set.all()    多对一:对象.关系属性模型管理器:    也是在models中编写，    格式:        class xxx (models.Manager):            可以定义方法或者定义查询（all）元选项(指定表名):    class Meta:        db_table &#x3D; &#39;xxx&#39;    verbose_name &#x3D; &#39;xxx&#39;    verbose_name_plural &#x3D; verbose_name    每个需要自定义表名的模型下方都要写这个代码，否则用系统给的表明,后两行代码代表指定在后台显示什么名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二大点-views-视图的使用"><a href="#第二大点-views-视图的使用" class="headerlink" title="第二大点:views,视图的使用"></a>第二大点:views,视图的使用</h2><pre class="line-numbers language-none"><code class="language-none">1、项目中的urls中加入应用中的urls中的所有，表示项目启动以后可以使用应用的链接配置2、应用中的urls用于配置浏览器页面输入的地址，一般只配置‘&#x2F;’以后的3、编写views文件，写清楚每个url的动作，定义在函数中,需要返回值4、views文件中所写的代码就是写应该在网页中现实的东西5、如果要使用模板，需要在项目文件夹下创建一个templates文件夹，并且配置好路径6、return HttpResponse(xx),不用模板   return HttpResponseRedirect(地址),redirect(地址)，两个功能一样都是重定向，在数据库添加后及时显示时候用   return render(request, &#39;模板文件位置&#39;,&#123;参数&#125;)重点:关于数据库的操作:导入 models  (类)    关于网页内容操作:导入 views   (函数)seting 中的设置，要改一起改    setting 中的DEBUG属性(调试模式):默认是True，改成False后可以显示标准的报错页面    setting 中的ALLOWED_HOSTS属性(允许访问):默认注释了的，是一个列表，ALLOWED_HOSTS &#x3D; [&#39;*&#39;]表示所有用户都可访问给视图传参数: 在urls中配置url的时候，给一个正则的分组就表示给视图传参数:            第一种:直接分组:views中的形参可以随便定义 :url(r&#39;^index(\d+)$&#39;,views.show)--&gt;def show(request,a)            第二种:分组命名:views长的形参必须和分组的名字一致  :url(r&#39;^index(?p&lt;num&gt;\d+)$&#39;,views.show)--&gt;def show(request,num)request参数:    def index (request)中使用,躲在用于登陆的时候使用        request.POST:保存的是网页中用post方式提交的参数，参数保存在请求头中        request.GET:保存的是网页中用get方式提交的参数，参数保存在url中    使用方法:        xx &#x3D; request.POST.get(&#39;xxx&#39;)        xx &#x3D; request.GET.get(&#39;xxx&#39;) 重点:    如果是网页模板，那么需要创建一个templates文件夹在项目文件夹下并且setting中配置路径，上面也提到过    如果是静态的文件，js，css，image这些文件的话，需要在项目文件夹下创建一个static文件夹，平且在setting中配置STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39; 和 STATICFILES_DIR &#x3D; [os.path.join(BASE_DIR,&#39;刚刚创建的文件夹static&#39;)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Cookie（多用于记住用户名）"><a href="#Cookie（多用于记住用户名）" class="headerlink" title="Cookie（多用于记住用户名）"></a>Cookie（多用于记住用户名）</h3><pre class="line-numbers language-none"><code class="language-none">Cookie的设置:需要一个HttpResponse的对象或者他的子类的对象，set_cookie取出cookie:request对象的COOKIES中设置:    xxx  &#x3D;  HttpResponse() 实例化HttpResponse的对象    xxx.set_cookie(&#39;key&#39;,value,max_age &#x3D; x) max_age是这只cookie的生存周期的，单位为秒    xxx.set_cookie(&#39;key2&#39;,value2,max_age &#x3D; x)    return xxx取出:    xxx &#x3D; request.COOKIES[&#39;key&#39;]    return HttpResponse(xxx)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="session-多用于银行卡-登录状态"><a href="#session-多用于银行卡-登录状态" class="headerlink" title="session(多用于银行卡,登录状态)"></a>session(多用于银行卡,登录状态)</h3><pre class="line-numbers language-none"><code class="language-none">session是一个特殊的Cookie,他的安全性更高，只给浏览器一个cookie编号,更重要的是，session可以记住用户的登录状态读取设置都在request设置session:    request.session[&#39;key&#39;] &#x3D; value    request.session[&#39;key2&#39;] &#x3D; value2    request.set_expiry(xx) 设置存活时间，整数，秒    return HttpResponse(request)获取:    xxx &#x3D; request.session[&#39;xx&#39;]    xxx &#x3D; request.session[&#39;xx&#39;]    xxx &#x3D; request.session.get(&#39;xx&#39;)    return HttpResponse(xx)登录状态:    判断有没有这个键:request.session.has_key[&#39;&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三块-模板templates"><a href="#第三块-模板templates" class="headerlink" title="第三块:模板templates"></a>第三块:模板templates</h2><pre class="line-numbers language-none"><code class="language-none">html里面的模板标签:    &#96;&#123;&#123;变量&#125;&#125;&#96;    &#96;&#123;% xx %&#125;&#96;  &#96; &#123;% endxx %&#125;&#96;    &#123;# 注释内容 #&#125;   &#96; &#123;% comment %&#125;&#96; 多行注释 &#96;&#123;% endcomment %&#125;&#96;过滤器:    格式: 模板变量 | 过滤器:参数    date:改变日期的显示格式    length:求字符串和列表的长度    default:设置不符合要求时候的默认值自定义过滤器:    在应用下创建一个templatetags包    在templatetags中创建过滤器xxx.py    在xxx.py中导入 from django.template import Library    实例化Library对象，xx &#x3D; Library()    定义一个函数，和python一样的，有返回值的    装饰一下，@xx.xxx    在html中加载，在最前面:&#96;&#123;% load xxx %&#125;&#96;    使用过滤器:变量 | xx    如果xx函数中有参数，竖线前面的变量就是参数，如果有两个以上的参数那么只用传n-1个参数模板继承:    被继承的html模板不动，在子html模板中删除html代码，只写一句&#96;&#123;% extends &#39;父模板地址&#39; %&#125;&#96; 地址相对于templates    在父模板中预留位置:子模板就可以重写父模板中预留的位置，从而保证有些不同 在父模板中&#96;&#123;% block 块名 %&#125;&#96; 可以写可以不写 &#96;&#123;% endblock 块名 %&#125;&#96;，子模板中也写&#96;&#123;% block 块名 %&#125; &#96;可以写可以不写 &#96;&#123;% endblock 块名 %&#125;&#96;，两边的两个标签需要一样块名一样，内容可以不一样    既要使用父模板中的预留内容，也要自定义预留内容:&#96;&#123;% block 块名 %&#125;&#96; &#96;&#123;&#123; block.super &#125;&#125;&#96;可以写可以不写 &#96;&#123;% endblock 块名 %&#125;&#96;    html转义:        在views.py 中render(request,&#39;html 路径&#39;, &#123;&#39;content&#39;:&#39;&lt;h1&gt;hello&lt;&#x2F;h1&gt;&#39;&#125;)        这样传过去的用的时候&#123;&#123;content&#125;&#125;，html并不会把传过来的&lt;h1&gt;当作标签，而是转义成了字符        解决方法:            &#123;&#123; content | safe &#125;&#125;csrf伪造攻击:    主要原因:        1、你在正常登录网站之后，浏览器保存了你的sessionid,而且你并没有退出        2、在没有退出的情况下，访问了其他的网站做了一些不好的操作，间接的修改你的密码    django默认启用了csrf防护，并且只针对post提交的数据防护，并且对包括自己的所有人防护    解决办法:        在html文件中有post提交的表单下方第一行输入&#96;&#123;% csrf_token %&#125;&#96;这样自己就可以正常使用了验证码(防止暴力请求):    用闭包的方式验证登录，有些界面只有登陆了才能使用    工作的时候网上取downurl 反向解析(给地址取个名字,然后直接用地址就可以动态的生成网页地址，不管网页地址怎么变化):    在项目中的urls中的链接应用url地址的地方添加第三个参数:url(r&#39;^&#39;, include(&#39;应用文件夹.urls&#39;), namespace&#x3D;&#39;应用文件夹名字&#39;)  ,namespace&#x3D;&#39;一般用应用名,也可以自定义&#39;    然后给应用中urls中的每一个自定义的链接取名:url(r&#39;^xxx$&#39;,views.xx, name &#x3D; &#39;取名&#39;)    在html中使用:        1、&lt;a href &#x3D;&#96; &#123;% url &#39;namespace:name&#39; %&#125;&#96;  url地址中没有参数  url(r&#39;^xx$&#39;, views.xx, name &#x3D; &#39;name&#39;)        2、&lt;a href &#x3D;&#96; &#123;% url &#39;namespace:name&#39; 1%&#125;&#96;  url地址中有一个参数   url(r&#39;^xx&#x2F;(\d+)$&#39;, views.xx, name &#x3D; &#39;name&#39;)        3、&lt;a href &#x3D; &#96;&#123;% url &#39;namespace:name&#39; 1 3%&#125; &#96; url地址中有两个参数   url(r&#39;^xx&#x2F;(\d+)&#x2F;(\d+)$&#39;, views.xx, name &#x3D; &#39;name&#39;)        *4、&lt;a href &#x3D; &#96;&#123;% url &#39;namespace:name&#39; a&#x3D;1 b&#x3D;3%&#125;&#96;  url地址中有两个被取名的参数   url(r&#39;^xx&#x2F;(?P&lt;a&gt;\d+)&#x2F;(?P&lt;b&gt;\d+)$&#39;, views.xx, name &#x3D; &#39;name&#39;)    在views中使用:        from django.core.urlresolvers import reverse        1、reverse(&#39;namespace:name&#39;) url地址中没有参数  url(r&#39;^xx$&#39;, views.xx, name &#x3D; &#39;name&#39;)        2、reverse(&#39;namespace:name&#39;, args &#x3D; (1)) url地址中有一个参数   url(r&#39;^xx&#x2F;(\d+)$&#39;, views.xx, name &#x3D; &#39;name&#39;)        3、reverse(&#39;namespace:name&#39;, args &#x3D; (1,3) url地址中有两个参数   url(r&#39;^xx&#x2F;(\d+)&#x2F;(\d+)$&#39;, views.xx, name &#x3D; &#39;name&#39;)        *4、reverse(&#39;namespace:name&#39;, kwargs &#x3D; &#123;&#39;a&#39;:1, &#39;b&#39;:2&#125;) url地址中有两个被取名的参数   url(r&#39;^xx&#x2F;(?P&lt;a&gt;\d+)&#x2F;(?P&lt;b&gt;\d+)$&#39;, views.xx, name &#x3D; &#39;name&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态文件-css-js-image"><a href="#静态文件-css-js-image" class="headerlink" title="静态文件(css\js\image)"></a>静态文件(css\js\image)</h3><pre class="line-numbers language-none"><code class="language-none">在项目文件夹中创建static文件夹在setting中配置:    STATIC_URL &#x3D; &#39;&#x2F;定义网址以什么开头&#x2F;&#39;  一般都是static        这里的名字如果想要随便改，然后在html中动态生成的话，在html中加载 &#96;&#123;% load staticfiles %&#125; &#96; 在要使用的地方用&#96;&#123;% static &#39;文件路径&#39; %&#125;&#96;这样进行拼接    STATICFILES_DIR &#x3D; [拼接文件夹位置]静态文件的使用实在html中的链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre class="line-numbers language-none"><code class="language-none">1、获取浏览器端的ip地址: request.META[&#39;REMOTE_ADDR&#39;],可以设置某些ip访问网站2、中间件的左右就是在每一个视图函数调用之前都会先执行中间件，可以判断某些用户或者界面不能使用，如判断是否登录，判断ip是否被禁止3、定义中间件的方法:    在应用中新建一个middleware.py 的python文件    中间件的构成:        class xxxx(object):   中间件类            xxx            def process_view(self, request, view_func, *view_args, **view_kwargs)  中间件函数                xxx                return xxx4、定义了中间件以后，我们需要在setting中注册：找到MIDDLEWARE_CLASSES，然后&#39;应用名.middleware.中间类5、中间件函数是内置的，只能使用内置的那么几个:    process_view(self, request, view_func, *view_args, **view_kwargs) : url匹配之后，视图调用之前    process_request(self, request) : 产生request对象之后， url匹配之前调用    __init__(self) : 服务器响应第一个请求的时候调用    process_response(self, request, response) : 视图调用之后，内容返回浏览器之前,需要return response    process_exception(self, request, exception) : 视图函数出现异常的时候调用，如果有多个exception，则按照注册的从后往前执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四模块Admin后台管理"><a href="#第四模块Admin后台管理" class="headerlink" title="第四模块Admin后台管理"></a>第四模块Admin后台管理</h2><pre class="line-numbers language-none"><code class="language-none">1、创建用户:python manage.py createsuperuser2、登录用户:网址&#x2F;admin3、注册模型类:在models.py中定义模型（将数据库中的数据加载到后台管理页面），在admin.py中去注册这个模型，admin.site.register(模型名字)上传图片:    在static文件夹中新建一个media文件夹，用于保存用户的头像等    在setting中设置MEDIA_ROOT &#x3D; 拼接文件夹,MEDIA_URL &#x3D; &#39;&#x2F;media&#x2F;&#39;    后台管理界面上传图片:创建一个数据库模型，定义一个字段，类型为ImageField(upload_to &#x3D; &#39;media中的某个文件夹&#39;)浏览器上传的照片:    表单的提交方式和编码方式必须如下    &lt;form method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;&#x2F;upload_down&quot;&gt;        &#96;&#123;% csrf_token %&#125;&#96;        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;pic&quot;&gt;&lt;br&#x2F;&gt;        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;    &lt;&#x2F;form&gt;        读取照片页面信息并保存：    def upload(request):        return render(request, &#39;upload.html&#39;)    def upload_down(request):        pic &#x3D; request.FILES[&#39;pic&#39;]        pic_path &#x3D; f&#39;&#123;settings.MEDIA_ROOT&#125;&#x2F;user_admin&#x2F;&#123;pic.name&#125;&#39;        with open(pic_path, &#39;wb&#39;) as pf:        for content in pic.chunks():            pf.write(content)        PicInfo.objects.create(pic_super&#x3D;f&#39;user_admin&#123;pic.name&#125;&#39;)        return HttpResponse(&#39;ok&#39;)浏览器上传的图片：    pic &#x3D; request.FILES[&#39;xx&#39;]的对象：pic.name获取文件名,pic.chunks()分块读取内容进行保存，pic.size获取上传文件的大小都是常用的分页（ 在view.py中和html代码中使用）:    需要包：from django.core.paginator import Paginator    Paginator属性:num_pages:返回分页的总页数,page_range:返回分页的页码列表    Paginator方法:page(self,number)：返回低number页的Page实例对象    Page的属性:number:返回当前页的页码，object_list：返回包含当前页的数据的查询集，paginator:返回对应的Paginator对象    page的方法:has_previous:判断是否有前一页,has_next:判断是否有下一页,previous_page_number:放回前一页,next_page_unmber:返回下一页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第五模块-url匹配"><a href="#第五模块-url匹配" class="headerlink" title="第五模块(url匹配)"></a>第五模块(url匹配)</h2><pre class="line-numbers language-none"><code class="language-none">可以用path，urlfrom django.urls import path,include或者from django.conf.urls import url,include在project的urls.py中，使用反向解析用到include,在include中添加参数namespace空间命名，可以进行反向解析，在应用中的urls.py中的urlpatterns上面添加一句app_name&#x3D;&#39;xx&#39;这个名字和namespace的名字相同。在应用的urls.py中，想使用反向解析，不需要include,可以直接在最后添加参数，name&#x3D;&#39;xx&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><pre class="line-numbers language-none"><code class="language-none">pip install itsdangerousfrom itsdangerous import TimedJSONWebSignatureSerializer创建一个TimedJSONWebSignatureSerializer对象: xx &#x3D; TimedJSONWebSignatureSerializer(&#39;加密秘钥&#39;，过期时间)加密：加密结果 &#x3D; TimedJSONWebSignatureSerializer对象.dumps(数据)解密: 解密结果 &#x3D; TimedJSONWebSignatureSerializer对象.loads(加密结果)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异步发邮件"><a href="#异步发邮件" class="headerlink" title="异步发邮件"></a>异步发邮件</h2><pre class="line-numbers language-none"><code class="language-none">pip install celery项目中新建一个任务包，在这个包中使用celery（from celery import Celery）创建Celery的实例对象：xx &#x3D; Celery(&#39;名字&#39;，broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;),broker代表中间人定义需要异步处理的函数，用@xx.task装饰在需要用到异步处理的应用中使用：    导入过来的函数.delay(参数)再将整个项目复制一份，进入复制的项目中的celery的包中：    import os    os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;dalifresh.settings&#39;)    django.setup()然后再终端输入命令:celery -A 取好的名字 worker -l info来运行这个异步处理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2023/01/19/redis-ji-chu/"/>
      <url>/2023/01/19/redis-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="NoSQL一种新出现的数据库-not-only-sql"><a href="#NoSQL一种新出现的数据库-not-only-sql" class="headerlink" title="NoSQL一种新出现的数据库(not only sql)"></a>NoSQL一种新出现的数据库(not only sql)</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、不认识sql语句2、存储结构和关系型数据库中的关系表完全不同，nosql存储的数据都是kv（key-value）形式3、nosql的世界没有一种通用的语言，每一种nosql数据库都有自己的api和语法，以及应用场景4、nosql的产品种类多### Redis数据库1、支持数据的持久化2、支持简单的key-vlaue，还有list,set,zset,hash等类型3、支持备份，master-slave模式的数据备份<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、字符串string2、哈希hash3、列表list4、集合set5、有序集合zset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Redis操作行为"><a href="#Redis操作行为" class="headerlink" title="Redis操作行为"></a>Redis操作行为</h3><pre class="line-numbers language-none"><code class="language-none">1、保存2、修改3、获取4、删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><blockquote><p>redis中最基础的数据类型，是二进制安全的，可以接受任何格式的数据，照片、json等</p></blockquote><ul><li>   定义字符串:set key value,  setex key sconds value 这种方式设置过期时间，  mset key value key value设置多个</li><li>   查看字符串:get key，mget key1 key2,获取多个</li><li>   字符串的追加:append key value</li><li>   查看所有的键:keys 通配符</li><li>   查看键是否存在:exists key</li><li>   查看键值的类型:type key</li><li>   设置过期时间:expire key sconds</li><li>   查看键的有效时间:ttl key</li><li>   删除:del key1 key2……</li></ul><h4 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h4><blockquote><p>hash本来就有key，hash的value就是一个字符串string，所以还有一个string的key</p></blockquote><ul><li>   定义哈希类型:hset key string-key value，  hmset key string-key1 value1 string-key2 value2一次设置多个，一个hash中可以有多个value</li><li>   查看指定键的值：hkey key</li><li>   获取hash的值:hget key string-key,   hmget key string-key1 string-key2……多个值，  hvals key获取所有的值</li><li>   删除:del key，删除整个hash，hdel key string-key删除对应的hash值</li></ul><h4 id="列表类型（list）"><a href="#列表类型（list）" class="headerlink" title="列表类型（list）"></a>列表类型（list）</h4><ul><li>   定义：lpush key value vlaue2……从左侧插入，rpush key value value2…… 从右侧插入，linsert key before或者after 某一个已经存在的value value value2……</li><li>   获取:lrange key start stop</li><li>   修改:lset key index new_value</li><li>   删除:lrem key count value,count是一个数字，表示删除多少个（相同元素），整数表示前往后，负数从后往前，为0的时候表示删除所有给定的value</li></ul><h4 id="集合类型-set"><a href="#集合类型-set" class="headerlink" title="集合类型(set)"></a>集合类型(set)</h4><blockquote><p>不能重复，无序</p></blockquote><ul><li>   定义:sadd key value value2……</li><li>   获取:smenbers key获取所有元素</li><li> 删除:srem key value value2……</li></ul><h4 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合(zset)"></a>有序集合(zset)</h4><blockquote><p>有序权重从小到大排序</p></blockquote><ul><li>   定义:zadd key 权重 value 权重2 value2……,权重就是数字</li><li>   获取:zrange key start stop</li><li>   获取给定的权值范围元素:zrangebyscore key start stop</li><li>   获取权值:zscore key value</li><li>   删除指定的元素:zrem key value1 value2……</li><li>   删除给定权值范围元素:zremrangebyscore key start stop</li></ul><h4 id="Redis和python的交互"><a href="#Redis和python的交互" class="headerlink" title="Redis和python的交互:"></a>Redis和python的交互:</h4><h5 id="python基本使用"><a href="#python基本使用" class="headerlink" title="python基本使用"></a>python基本使用</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> redis <span class="token keyword">import</span> <span class="token operator">*</span>xx <span class="token operator">=</span> StrictRedis<span class="token punctuation">(</span>host <span class="token operator">=</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> port <span class="token operator">=</span> <span class="token number">6379</span><span class="token punctuation">,</span> db <span class="token operator">=</span> num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>对xx进行操作</p></blockquote><h5 id="django中使用Redis-多数用来-存储session"><a href="#django中使用Redis-多数用来-存储session" class="headerlink" title="django中使用Redis:多数用来 存储session"></a>django中使用Redis:多数用来 存储session</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install django<span class="token operator">-</span>redis<span class="token operator">-</span>sessions<span class="token comment"># setting.py中设置：</span>SESSION_ENGINE <span class="token operator">=</span> <span class="token string">'redis_sessions.session'</span>SESSION_REDIS_HOST <span class="token operator">=</span> <span class="token string">'localhost'</span>SESSION_REDIS_PORT <span class="token operator">=</span> <span class="token number">6379</span>SESSION_REDIS_DB <span class="token operator">=</span> <span class="token number">2</span>SESSION_REDIS_PASSWORD <span class="token operator">=</span> <span class="token string">''</span>SESSION_REDIS_PREFIX <span class="token operator">=</span> <span class="token string">'session'</span><span class="token comment"># 这样就可以将原本存储在django的数据库中的session存储到redis中，存储成hash</span><span class="token comment"># 配置成caches:</span>CACHES <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"default"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"BACKEND"</span><span class="token punctuation">:</span> <span class="token string">"django_redis.cache.RedisCache"</span><span class="token punctuation">,</span>    <span class="token string">"LOCATION"</span><span class="token punctuation">:</span> <span class="token string">"redis://127.0.0.1:6379/2"</span><span class="token punctuation">,</span>    <span class="token string">"OPTIONS"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"CLIENT_CLASS"</span><span class="token punctuation">:</span> <span class="token string">"django_redis.client.DefaultClient"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment"># 使用</span><span class="token keyword">from</span> dajango_redis <span class="token keyword">import</span> get_redis_connectionxxx <span class="token operator">=</span> get_redis_connection<span class="token punctuation">(</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token comment"># 可以使用redis中的所有方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="redis的问题"><a href="#redis的问题" class="headerlink" title="redis的问题"></a>redis的问题</h3><blockquote><p>   缓存穿透：用户查询一个数据库中一定不会有的数据，比如id=-1,因为数据库中没有这个数据，所以不会保存到缓存中，下次再来访问的时候，缓存中没有，又会去数据库中查询，这样就增加了数据库的压力，如果被黑客发现了，就会利用这个漏洞来攻击数据库，可能会让数据库崩溃，解决办法就是就算没有查到，也放到缓存中，只不过值为null，然后把过期时间设置的短一点。</p></blockquote><blockquote><p>   缓存雪崩：意思就是大量的缓存数据同时失效（过期），这个时候，又有大并发的请求的话，就会对数据库加大访问压力，可能让数据库崩溃，解决办法就是，可以设置不同的过期时间，如果是双十一这种可以设置永不过期。</p></blockquote><blockquote><p>   缓存击穿：意思就是用户频繁会访问的key，比如，双十一有一个活动见做一分钱领取iphone13 pro max，在非常多的人访问的时候，在这种大并发的情况下，如果缓存中的这个key过期了，那么对数据的压力就太大了，解决办法就是设置这个key用不过期。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git笔记</title>
      <link href="/2023/01/19/git-bi-ji/"/>
      <url>/2023/01/19/git-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Git（文件只有放入了暂存区之后才会被追踪）"><a href="#Git（文件只有放入了暂存区之后才会被追踪）" class="headerlink" title="Git（文件只有放入了暂存区之后才会被追踪）"></a>Git（文件只有放入了暂存区之后才会被追踪）</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>   版本控制:解决多人同时开发的代码问题，解决找回历史代码的问题</li><li>   分布式:Git是分布式版本控制系统，如同一个GIT仓库，可以分不到不同的机器上，工作原理:找一台电脑做服务器（中央服务器），不关机，其他的人可以把这个服务器克隆到自己的电脑上</li></ul><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建版本-两步"><a href="#创建版本-两步" class="headerlink" title="创建版本(两步)"></a>创建版本(两步)</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> 文件<span class="token function">git</span> commit <span class="token parameter variable">-m</span> ‘版本说明’ <span class="token comment"># 版本:第一次创建版本的时候是记录里面的内容，以后的版本都是保存被修改的信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="查询版本记录信息"><a href="#查询版本记录信息" class="headerlink" title="查询版本记录信息"></a>查询版本记录信息</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> log<span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline <span class="token comment"># 更好用</span><span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline <span class="token comment"># 可以查看分支图</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="版本的回退"><a href="#版本的回退" class="headerlink" title="版本的回退"></a>版本的回退</h4><blockquote><p>   有一个指针HEAD指向最新的版本， 上一个版本可以被表示为</p></blockquote><blockquote><p>HEAD^,一个^表示前一个版本，100个^表示第前100个版本,还可以表示为:HEAD<del>1,HEAD</del>100,分别表示前一个和前100个版本</p></blockquote><blockquote><p>版本回退命令</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset –hard HEAD~1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>版本前进命令</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset –hard 版本编号 <span class="token comment">#（commit) 版本编号可以通过git reflog来查看，这里面都是操作记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>就是使用git init命令的目录，创建文件和编辑文件都是在工作区完成的<br>版本库:拥有暂存区,HEAD区</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> <span class="token comment"># 就是添加修改到暂存区,git commit就是创建版本</span><span class="token function">git</span> status <span class="token comment"># 可以查看工作区的情况</span><span class="token function">git</span> <span class="token function">add</span> <span class="token comment"># 可以同时添加很多个文件（也可以是目录）到暂存区，用空格分别，并且使用git commit的时候可以将同时提交的所有文件，创建一个版本，</span><span class="token function">git</span> checkout – 文件名 <span class="token comment"># 在没有加到暂存区可以直接用这个命令丢弃修改(删除以后也可用这个恢复)，如果已经加到了暂存区，可以通过git reset HEAD 文件名解除添加到暂存区，然后用这个命令直接放弃修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>rm 文件名,因为是对工作区的文件的修改，所以可以用git checkout恢复，也可以用git rm将删除放入暂存区，彻底删除。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：使用rm第二步：如果要恢复,git checkout --文件名,如果要删除，git rm放入暂存区第三步: 如果删除文件的修改被放入了暂存区，可以用git reset HEAD 文件名 解除暂存，然后用git checkout恢复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="git-分支的概念-比如两个平行的宇宙，出现了交点"><a href="#git-分支的概念-比如两个平行的宇宙，出现了交点" class="headerlink" title="git 分支的概念(比如两个平行的宇宙，出现了交点)"></a>git 分支的概念(比如两个平行的宇宙，出现了交点)</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git主分支:master分支,HEAD指向master然后master再指向提交的指针git从分支:dev分支，和master分支相互独立，可以和master分支合并，还可以删除<span class="token function">git</span> branch可以查看有多少个分支创建分支: <span class="token function">git</span> branch 名字创建新的分支并切换到新分支: <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> dev（名字随便取）,创建了dev分支，HEAD就会指向dev切换到master分支: <span class="token function">git</span> checkout master将dev分支的东西合并到master（一般都是合并在master分支上，也可以合并到其他的相关分支上，比如修复hug的时候）：git merge dev删除dev分支：git branch <span class="token parameter variable">-d</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 分支合并冲突:master分支和其他分支都修改了同一个文件的版本，合并就会报错，解决办法就是手动解决 </p></blockquote><blockquote><p> 分支的管理决策: 在两个分支中修改了不同的文件的版本，那么合并的时候，就不会是快速合并,而是跳出一个弹框,第一行写入你的说明信息，退出之后合并完成，或者git merge –no-ff -m 合并版本说明 合并的分支， 这样可以禁用快速合并，保留分支的文件信息</p></blockquote><blockquote><p> 分支bug管理:当我们在一个分支上进行工作的时候，其他的分支有bug需要及时的修复，那么可以使用git stash保存正在工作的分支上的状态，然后马上去需要修复bug的分支上修复bug：</p></blockquote><ul><li>   首先我们要确定在哪一个分支上修复bug </li><li>   然后在到那个分支上创建一个临时的分支来修复这个bug </li><li>   然后切换回出hug的分支</li><li>   然后合并分支，并用 git merge –no-ff -m ‘说明信息’ 临时分支,用来保存bug记录</li><li>   然后删除临时分支，在修复完成以后,再回到最初工作的分支</li><li>   用git stash pop恢复工作现场就可以继续工作（用git stash list 可以查看保存的工作现场的列表)</li></ul><h4 id="链接远程的仓库"><a href="#链接远程的仓库" class="headerlink" title="链接远程的仓库"></a>链接远程的仓库</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">生成ssh公钥:ssh-keygen -t rsa -C'749062870@qq.com'一直回车(3个)生成的ssh存放在用户文件夹下面的.ssh下面将.ssh下面的id_rsa.pub内容复制到github使用ssh -T git@github.com来测试是否连通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="GitHub："><a href="#GitHub：" class="headerlink" title="GitHub："></a>GitHub：</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、创建新的仓库(同git中的git init): start project  => 项目名称 => 公开 => 两个add(readme使用说明，gitignore忽略文件)2、添加ssh账户(本机和github交互):创好仓库之后，点击头像下拉，找到settings => SSH and GPG keys => New SSH key就可以添加本地ssh账户，Title随便写,Key则需要本地的ssh公钥，（生成本地电脑的ssh公钥，回到家目录，编辑vim .gitconfig,然后ssh-keygen -t rsa -C '749062870@qq.com'一直回车，完成之后，cd ssh，然后cat id_rsa.pub，复制过去就行了）3、克隆项目:github中的仓库中，code下拉中，选择ssh(我们用的就是ssh)，复制地址到相对应的文件夹下用终端 git clone 复制的地址, 将github中的项目下载到本地4、推送代码:被下载到本地的项目,不用master分支开发，而是创建一个自己的分支，一直在自己的分支上开发，开发完成之后先add，commit到本地，然后可以用git push origin 分支名称，就可以推送到github上面5、追踪远程分支：git branch --set-upstream-to=origin/远程分支 本地分支,追踪之后，就可以用git status来查看本地分支和远程分支的提交情况6、拉去代码: git pull origin 要拉取的分支.从远程分支上下载，拉取代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>链接——&gt;切换分支–&gt;add—&gt;commit—-&gt;push到lqs</p></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">'用户名'</span> <span class="token comment"># 修改配置的用户名</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">'邮箱'</span>  <span class="token comment"># 修改配置的邮箱</span><span class="token function">git</span> init <span class="token comment"># 初始化git仓库</span><span class="token function">git</span> status <span class="token comment"># 查看工作区的文件是否被管理</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> <span class="token comment"># 把工作区的文件提交到暂存区，也就是将工作区的文件进行管理</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'日志'</span> <span class="token comment"># 将暂存区的文件提交到本地仓库</span><span class="token function">git</span> log <span class="token comment"># 查看提交的日志，点击q退出</span><span class="token function">git</span> branch <span class="token comment"># 查看本地分支</span><span class="token function">git</span> branch <span class="token parameter variable">-a</span> <span class="token comment"># 查看本地和远程的分支</span><span class="token function">git</span> checkout <span class="token string">'远程分支'</span> <span class="token comment"># 可以从本地分支切换到远程分支</span><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token string">'分支名称'</span> <span class="token comment"># 新建并切换到分支</span><span class="token function">git</span> branch <span class="token parameter variable">-d</span> <span class="token string">'分支名称'</span> <span class="token comment"># 删除分支，分支被合并之后才允许删除</span><span class="token function">git</span> branch <span class="token parameter variable">-D</span> <span class="token string">'分支名称'</span> <span class="token comment"># 删除分支，强制删除</span><span class="token function">git</span> merge <span class="token string">'分支名称'</span> <span class="token comment"># 合并分支</span><span class="token function">git</span> push <span class="token string">'远程地址 '</span><span class="token comment"># 将本地仓库推送到远程仓库或者如下</span><span class="token function">git</span> remote <span class="token function">add</span> origin <span class="token string">'远程地址'</span> <span class="token comment"># 给远程仓库添加别名</span><span class="token function">git</span> push <span class="token parameter variable">-u</span> origin <span class="token string">'分支名称'</span> <span class="token comment"># 远程仓库没有这个分支，第一次向远程仓库推送分支</span><span class="token function">git</span> push  <span class="token comment"># 第二次推送</span><span class="token function">git</span> clone <span class="token string">'远程地址'</span> <span class="token comment"># 克隆远程仓库的代码</span><span class="token function">git</span> pull <span class="token string">'远程地址'</span> <span class="token string">'远程分支'</span> <span class="token comment"># 拉去远程仓库的代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonWebSocket笔记</title>
      <link href="/2023/01/19/pythonwebsocket-bi-ji/"/>
      <url>/2023/01/19/pythonwebsocket-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="udp的数据通信"><a href="#udp的数据通信" class="headerlink" title="udp的数据通信"></a>udp的数据通信</h2><pre class="line-numbers language-none"><code class="language-none">1、socket:创建套接字2、bind:绑定本地端口，接收数据必须绑定，发送数据可以不绑定3、sendto、recvfrom:接收发送数据4、close:关闭套接字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tcp的数据通信"><a href="#tcp的数据通信" class="headerlink" title="tcp的数据通信"></a>tcp的数据通信</h2><blockquote><p>   客户端</p></blockquote><pre class="line-numbers language-none"><code class="language-none">1、socket:创建套接字*、bind:绑定端口号，客户端可以不用绑定，使用随机端口即可2、connect:链接服务器3、send、recv:接收发送数据4、close:关闭套接字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  服务器</p></blockquote><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、socket:创建套接字*、setsock：套接字.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)，在客户端关闭之前，服务器首先关闭，关闭（close)2、bind:一定要绑定端口信息3、listen:使得主动变成被动4、accept:等待客户端链接5、send、recv:收发数据6、close:关闭套接字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python正则</title>
      <link href="/2023/01/19/python-zheng-ze/"/>
      <url>/2023/01/19/python-zheng-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><blockquote><p>   1、匹配单个字符</p></blockquote><ul><li>. :点号表示匹配任意的一个字符（除了\n),类似于ACCESS当中的？</li><li>[]:方括号表示匹配[]当中的任何一个字符，[1-9],[1-35-8],[asbdef],[a-be-zA-Z0-4]都是可以的[AaBb]都是可以的</li><li>\d:表示匹配任意一个数字（0-9）</li><li>\D:表示匹配数字以外的任意一个其他字符</li><li>\s:表示匹配任意一个空白，tab或者空格或者换页符等等</li><li>\S:表示匹配一个非空白字符，除了空白以外的其他任意字符</li><li>\w:表示匹配任意一个字母、数字、下划线，还有一种用法：\w可以用来表示除了特殊字符以外的所有字符，包括汉字</li><li>\W:表示匹配任意一个特殊字符</li><li>使用方法:re.match(r’规则’,’要处理的字符串’).group(),  match用来创建，group用来查看返回值</li></ul><blockquote><p>匹配多个字符</p></blockquote><ul><li>{}:大括号表示它前面紧挨着的那个字符出现的次数，{3,6},表示出现3到6次都可以，可以出现4，也可以出现3，只要在3到6的范围内都可以,{8}表示强制它前面紧挨着的字符必须出现8次</li><li>？:表示？前面紧挨着的一个字符要么出现一次要么不出现</li><li>+:表示前面紧挨着的哪一个字符出现至少一次到无限次。和.连用‘.+’表示取出所有，前提是必须有至少一个字符</li><li>*:表示前面紧挨着的哪一个字符出现0次到无限次。和.连用‘.*’表示取出所有</li><li>[^字符]:表示除了这个字符以外的</li><li>[^字符]*:表示除了多个或者没有这个字符以外的</li><li>  ^：表示必须，如果在[]里面意思就相反，表示除了</li></ul><blockquote><p>分组</p></blockquote><ul><li><p>|:与分组结合使用表示匹配分组中的任意一个字符串，(qq|web)，表示匹配qq或者web中的任意一个</p></li><li><p>():分组，把正则表达式分成多组，从左往右组号升序</p></li><li><p> \num:与分组结合使用，多次出现相同的规则的时候可以用\num来调用前面封装好的规则，如 \1 表示调用前面的第一个分组的规则</p></li><li><p>分组的取名和调用：</p></li><li><p>1、可以不取名，直接用组号 用第一个分组：\1   ，  用第二个分组：\2 以此类推</p></li><li><p>2、当分组十分的多的时候，可以取名：原来的分组：(\w*)  取名后的分组:(?P<name1>\w*)    ?P<name1>就是取名的表达式</p></li><li><p> 3、使用取名后的分组：原来使用(\1)   用名字使用:(?P=name1)</p></li></ul><blockquote><p>re模块的高级用法</p></blockquote><ul><li>1.search: re.search(r’规则’,’字符串’) 表示从这些字符串中找到符合规则的第一个数据</li><li>2、findall: re.findall(r’规则’,’字符串’) 表示从这些字符中找到所有的符合规则的数据，返回一个列表</li><li> 3、sub: re.sub(r’规则’,’替换字符串’,’字符串’) 表示从这些字符中找到所有的符合规则的数据，然后全部替换成用来替换的字符串</li><li>4、spilt: re.spilt(r’规则’,’字符串’) 表示从这些字符串中找到符合规则的数据，并且从那里开始分割字符串，返回一个列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python装饰器</title>
      <link href="/2023/01/19/python-zhuang-shi-qi/"/>
      <url>/2023/01/19/python-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><blockquote><p>原理:将一个函数的引用传递到另一个闭包里面去</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func_set</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span>函数<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">func_start</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"验证一"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"验证二"</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> func_start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用方法一</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@func_set</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>使用方法二</p></blockquote> <pre class="line-numbers language-python" data-language="python"><code class="language-python">ret <span class="token operator">=</span> func_set<span class="token punctuation">(</span>test<span class="token punctuation">)</span>ret<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>说明:装饰器的闭包中，外部函数用来接收函数，内部函数用来接收函数的参数，并且在没有调用函数之前只要有@就开始装饰,在装饰不定长的函数时</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>这种函数的装饰器的内部函数参数定义为(*args, **kwargs)就可以了，这种装饰器叫做通用装饰器,遇到有返回值的函数的时候，装饰器的内部函数也要有return，格式:return 函数（参数）</li></ul><h3 id="装饰器带参数"><a href="#装饰器带参数" class="headerlink" title="装饰器带参数"></a>装饰器带参数</h3><blockquote><p>带参数的装饰器:@装饰器名称(参数)</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> 第一层<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token comment"># 第一层用来保存装饰器的参数</span>    <span class="token keyword">def</span> 第二层<span class="token punctuation">(</span>函数<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># 第二层用来保存被装的函数</span>        <span class="token keyword">def</span> 第三层<span class="token punctuation">(</span>函数的参数<span class="token punctuation">)</span><span class="token punctuation">:</span>           <span class="token comment"># 第三层用来保存被装函数的参数，并且进行装饰函数，并且使用第一层保存的装饰器参数</span>            语句块            <span class="token punctuation">[</span><span class="token keyword">return</span><span class="token punctuation">]</span> 函数        <span class="token keyword">return</span> 第三层    <span class="token keyword">return</span> 第二层<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>多个装饰器对同一个函数装饰:装饰的时候最下面的开始装,从下往上装</p></blockquote><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><blockquote><p>基本构架</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Tt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        代码        <span class="token punctuation">[</span><span class="token keyword">return</span><span class="token punctuation">]</span> self<span class="token punctuation">.</span>func<span class="token decorator annotation punctuation">@Tt</span>     <span class="token comment">#还可以点出更多东西以后会学到</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"haha"</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python进程线程协程</title>
      <link href="/2023/01/19/python-jin-cheng-xian-cheng-xie-cheng/"/>
      <url>/2023/01/19/python-jin-cheng-xian-cheng-xie-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="multiprocessing下面"><a href="#multiprocessing下面" class="headerlink" title="multiprocessing下面"></a>multiprocessing下面</h3><ul><li>1、Process:创建一个进程,参数有target，args,args是一个元组作为形式参数</li><li>2、start:运行这个进程</li><li>3、Queue:是队列，先进先出，和栈相反，Queue(20)就是说可以存放20个数据，数据部分类型。用full来判断是否满，用empty来判断是否空了用put来往里面放数据,用get来拿数据</li><li>4、Pool:进程池，实现重复利用，进程任务数量太多或者任务数不确定的时候，最好使用进程池。如果有10000个进程，那么创建一个只有10个任务的进程池，就可以反复一万次来完成任务，避免系统崩溃,利用for循环来创建进程，apply_async(函数，(参数，参数,),创建之后立刻关闭close，并且紧跟其后用join，否则程序死掉’</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> time<span class="token keyword">import</span> random<span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    t_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>    t_stop <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">执行时长:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>t_start<span class="token operator">-</span>t_stop<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    p <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        p<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>info<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="threading下面"><a href="#threading下面" class="headerlink" title="threading下面"></a>threading下面</h3><ul><li>   1、Thread:创建一个线程对像，可以有两个参数 target= ，args=，args是一个元组</li><li>   2、start：使用创建的线程</li><li>   3、enumerate:用来查看有多少个线程在跑，用len来显示个数，用while来控制</li><li>   4、Lock:互斥锁，可以实例出一个实力对象，require是上锁，release是解锁</li></ul><blockquote><p>说明一点:在用c语言编写的python解释器中执行python的线程的时候，会涉及到GIL锁，GIL锁就是同一时刻只有一个程序在执行，这是一种假的多任务，只有线程在有，解决GIL锁的方法</p><ul><li>1、换解释器</li><li>2、换线程语言(因为python基本可以执行其他的所有语言，c、c++、java等)</li></ul></blockquote><h3 id="线程共享全局变量"><a href="#线程共享全局变量" class="headerlink" title="线程共享全局变量"></a>线程共享全局变量</h3><ul><li>  1、如果在线程代码中对全局变量进行修改，要用global,也就是说要令全局变量’等于’一个什么东西的时候必须用global，如：i+=1，用变量的方法来修改的不用使用global，如list.append()</li><li>  2、如果没有要对全局变量进行修改，就不用global申明，只是使用全局变量也不用使用global</li><li>  3、全局变量在线程中也可以共享</li><li>  4、有可能在多线程中可能会出现资源争夺（用Local互斥锁来解决，互斥锁不要太多，用以产生死锁）</li></ul><h3 id="Thread的实例对象还可以是一个类"><a href="#Thread的实例对象还可以是一个类" class="headerlink" title="Thread的实例对象还可以是一个类"></a>Thread的实例对象还可以是一个类</h3><ul><li>  1、让这个类来继承threading.Thread这个类</li><li>  2、用的时候直接 对象名 = 这个类（）</li><li> 3、start的使用：这个类的对象名.start</li><li> 4、（最重要):这个类中只能进行多线程的就是run函数，所以如果要对类创建多线程，那么必须有run函数，类当中的其他函数只能通过 self.函数名 的形式申明在run函数中</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">Prison</span><span class="token punctuation">(</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">info2</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---info2----"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">info3</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---info3----"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 特别重要:只会调用run</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---info1----"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    info <span class="token operator">=</span> Prison<span class="token punctuation">(</span><span class="token punctuation">)</span>    info<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="yield协程"><a href="#yield协程" class="headerlink" title="yield协程"></a>yield协程</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">info1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-----1-----'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>        <span class="token keyword">yield</span><span class="token keyword">def</span> <span class="token function">info2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-----2-----'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>        <span class="token keyword">yield</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    in1 <span class="token operator">=</span> info1<span class="token punctuation">(</span><span class="token punctuation">)</span>    in2 <span class="token operator">=</span> info2<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  一定要用循环来切换        <span class="token builtin">next</span><span class="token punctuation">(</span>in1<span class="token punctuation">)</span>        <span class="token builtin">next</span><span class="token punctuation">(</span>in2<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="greenlet协程"><a href="#greenlet协程" class="headerlink" title="greenlet协程"></a>greenlet协程</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> greenlet <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">info1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-----1-----'</span><span class="token punctuation">)</span>        t2<span class="token punctuation">.</span>switch<span class="token punctuation">(</span><span class="token punctuation">)</span> 使用greenlet协程必须要使用switch来切换        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">info2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-----2-----'</span><span class="token punctuation">)</span>        t1<span class="token punctuation">.</span>switch<span class="token punctuation">(</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> greenlet<span class="token punctuation">(</span>info1<span class="token punctuation">)</span> 创建一个对象t2 <span class="token operator">=</span> greenlet<span class="token punctuation">(</span>info2<span class="token punctuation">)</span>t1<span class="token punctuation">.</span>switch<span class="token punctuation">(</span><span class="token punctuation">)</span> 开始调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gevent协程-最大的有点就是利用延时切换任务，充分利用cpu"><a href="#gevent协程-最大的有点就是利用延时切换任务，充分利用cpu" class="headerlink" title="gevent协程(最大的有点就是利用延时切换任务，充分利用cpu)"></a>gevent协程(最大的有点就是利用延时切换任务，充分利用cpu)</h3><pre class="line-numbers language-none"><code class="language-none">import geventdef f1(n):    for i in range(n):        print(&quot;----f1----&quot;, i)        gevent.sleep(0.3) # 用于延时，不用time.sleep(),而是用gevent.sleep()def f2(n):    for i in range(n):        print(&quot;----f2----&quot;, i)        gevent.sleep(0.3)def f3(n):    for i in range(n):        print(&quot;----f3----&quot;, i)        gevent.sleep(0.3)def main():    # 使用方法一、    t1 &#x3D; gevent.spawn(f1, 5)    t2 &#x3D; gevent.spawn(f2, 5)    t3 &#x3D; gevent.spawn(f3, 5)    t1.join()    t2.join()    t3.join()    # 使用方法二、    gevent.joinall([        gevent.spawn(f1, 5),        gevent.spawn(f2, 5),        gevent.spawn(f3, 5)    ])if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2023/01/19/die-dai-qi/"/>
      <url>/2023/01/19/die-dai-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>可以一个一个的取，取一个用一个，迭代器会主动暂停</p></blockquote><blockquote><ul><li>1、from collections import Iterator,这个类可以判断某个对象是不是迭代器</li></ul></blockquote><blockquote><ul><li>2、from collections import Iterable,这个类可以判断某个对象可不可以迭代，最主要的是它可以产生迭代器,如果要用Iterable来创建一个迭代器，那么必须使用__iter__方法和__next__方法，且两个方法是共生的，有了iter就一定有next，通过next来迭代，通过iter让对象可以迭代，这个对象多指不规律的，定义成一个类的,next的返回值用户要用for循环来遍历，next就是一个迭代的规则</li></ul></blockquote><blockquote><ul><li>3、可以一个一个的取，取一个用一个:方法</li></ul></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 取第一个</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 取第二个</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 取第三</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>可以用一个拿一个，不用就不管，生成器会自动暂停</p></blockquote><blockquote><ul><li>   1、生成器是一个特殊的迭代器，并且不需要导入任何的包，用了yield X的函数就是生成器，也就是说如果函数里面出现了yield，那么这个函数就不再是函数，而是一个生成器调用的时候，也是创建的生成器对象，</li><li>   2、生成器不会存储数据，而只是用来产生数据的，多就用多久拿出来使用，大大节省了存储空间</li><li>   3、生成器的启动方法:</li></ul></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">1</span>、re <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment"># 这样就会返回生成器中yield后面的值，也就是说re = yield后面的变量</span><span class="token number">2</span>、re <span class="token operator">=</span> send<span class="token punctuation">(</span><span class="token string">"传递的参数"</span><span class="token punctuation">)</span> <span class="token comment"># 传递的参数"就是给”yield x"整体赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><ul><li>   4、可以用一个拿一个，不用就不管</li></ul></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">re <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>re <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>re <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>re <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>re <span class="token operator">=</span> obj<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"hahah"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/01/19/bi-bao/"/>
      <url>/2023/01/19/bi-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包(python可以返回函数，特性之一)</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">startAt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">incrementBy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y    <span class="token keyword">return</span> incrementBy     a <span class="token operator">=</span> startAt<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包的格式"><a href="#闭包的格式" class="headerlink" title="闭包的格式"></a>闭包的格式</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span>……<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span>……<span class="token punctuation">)</span><span class="token punctuation">:</span>        代码    <span class="token keyword">return</span> func2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说明两点:</p><ul><li>global:用于函数内,修改全局变量和其他局部变量的时候申明，但是如果不修改全局变量也可以不使用global关键字</li><li>nonlocal:用于内部函数要修改外部函数的变量的时候申明，声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量</li></ul></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><blockquote><ul><li>定义:   变量名 = lambda 参数:返回值</li><li>调用:   变量名(参数)</li></ul></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token keyword">lambda</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">:</span> arg1 <span class="token operator">+</span> arg2<span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wifi密码破解</title>
      <link href="/2023/01/16/wifi-mi-ma-po-jie/"/>
      <url>/2023/01/16/wifi-mi-ma-po-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="aircrack-ng工具安装"><a href="#aircrack-ng工具安装" class="headerlink" title="aircrack-ng工具安装"></a>aircrack-ng工具安装</h3><blockquote><p>如果你是Kali用户，那么可以跳过这一步，Kali自带，我们以Ubuntu为例：</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> aircrack-ng <span class="token comment"># 安装aircrack-ng 这个工具kali-linux默认安装了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看无线网卡"><a href="#查看无线网卡" class="headerlink" title="查看无线网卡"></a>查看无线网卡</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">airmon-ng <span class="token comment"># 查看可用的无线网卡一般以`w`开头</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开启监听模式"><a href="#开启监听模式" class="headerlink" title="开启监听模式"></a>开启监听模式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">airmon-ng start <span class="token operator">&lt;</span>网卡名称<span class="token operator">></span> <span class="token comment"># 指定无线网卡开启监听模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="扫描附近的无线网"><a href="#扫描附近的无线网" class="headerlink" title="扫描附近的无线网"></a>扫描附近的无线网</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">airodump-ng <span class="token operator">&lt;</span>处于监听模式的网卡名称<span class="token operator">></span> <span class="token comment"># 用这个监听网卡扫描附近的无线网络</span><span class="token comment"># airodump-ng wlp8s0mon</span><span class="token comment"># BSSID: 无线 AP 的硬件地址</span><span class="token comment"># PWR: 信号强度，值是负数，绝对值越小表示信号越强</span><span class="token comment"># CH: 无线网络信道</span><span class="token comment"># ENC: 加密方式，我们要破解的是 WPA2</span><span class="token comment"># ESSID: 无线网络的名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="监听你想破解的无线网"><a href="#监听你想破解的无线网" class="headerlink" title="监听你想破解的无线网"></a>监听你想破解的无线网</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">airodump-ng <span class="token parameter variable">-w</span> <span class="token operator">&lt;</span>扫描结果保存的文件名<span class="token operator">></span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>无线网络信道<span class="token operator">></span> <span class="token parameter variable">--bssid</span> <span class="token operator">&lt;</span>目标无线 AP 的硬件地址<span class="token operator">></span> <span class="token operator">&lt;</span>处于监听模式的网卡名称<span class="token operator">></span> <span class="token comment"># 使用参数过滤扫描列表，确定扫描目标,可以出指定wifi哪些人在使用 只要有人链接这个wifi就会被抓包</span><span class="token comment"># BSSID: 无线 AP 的硬件地址</span><span class="token comment"># STATION: 用户设备的硬件地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对无线AP或者用户设备发起ACK攻击"><a href="#对无线AP或者用户设备发起ACK攻击" class="headerlink" title="对无线AP或者用户设备发起ACK攻击"></a>对无线AP或者用户设备发起ACK攻击</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aireplay-ng -<span class="token operator">&lt;</span>攻击模式<span class="token punctuation">(</span><span class="token number">0</span>为下线<span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&lt;</span>攻击次数<span class="token punctuation">(</span><span class="token number">0</span>为一直攻击<span class="token punctuation">)</span><span class="token operator">></span> <span class="token parameter variable">-a</span> 无线 AP 硬件地址<span class="token operator">></span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>用户设备硬件地址<span class="token operator">></span> <span class="token operator">&lt;</span>处于监听模式的网卡名称<span class="token operator">></span> <span class="token comment"># 使用 aireplay-ng 对目标设备发起ack攻击 让他强制下线 方便他重新链接抓包成功</span>aireplay-ng -<span class="token operator">&lt;</span>攻击模式<span class="token punctuation">(</span><span class="token number">0</span>为下线<span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&lt;</span>攻击次数<span class="token punctuation">(</span><span class="token number">0</span>为一直攻击<span class="token punctuation">)</span><span class="token operator">></span> <span class="token parameter variable">-a</span> 无线 AP 硬件地址<span class="token operator">></span> <span class="token operator">&lt;</span>处于监听模式的网卡名称<span class="token operator">></span> <span class="token comment"># 使用 aireplay-ng 对无线AP设备发起ack攻击 让连接他的设备都下线 方便他重新链接抓包成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="破解密码"><a href="#破解密码" class="headerlink" title="破解密码"></a>破解密码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aircrack-ng <span class="token parameter variable">-w</span> 密码字典 <span class="token operator">&lt;</span>包含握手包的 cap 文件<span class="token operator">></span> <span class="token comment"># 使用 aircrack-ng 暴力破解 Wi-Fi 密码 成功会返回 KEY FOUND! 密码字典去网上下载多得很 </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="退出监听模式，连接无线网"><a href="#退出监听模式，连接无线网" class="headerlink" title="退出监听模式，连接无线网"></a>退出监听模式，连接无线网</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">airmon-ng stop <span class="token operator">&lt;</span>处于监听模式的无限网卡名称<span class="token operator">></span> <span class="token comment"># 无线网卡退出监听模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用命令连接网络"><a href="#使用命令连接网络" class="headerlink" title="使用命令连接网络"></a>使用命令连接网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl start NetworkManager <span class="token comment"># 开启网络服务</span><span class="token function">ip</span> addr 或者 <span class="token function">ifconfig</span> <span class="token comment"># 查看无线网卡名称(w开头得)</span>iwlist 无线网卡 scanning <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> essid <span class="token comment"># 扫描可用wifi</span>nmcli device wifi connect wifi名字 password wifi密码 ifname 无线网卡 <span class="token comment"># 用这个无线网卡链接指定wifi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="卸载ubuntu系统的IO驱动，不让别人乱碰你得电脑"><a href="#卸载ubuntu系统的IO驱动，不让别人乱碰你得电脑" class="headerlink" title="卸载ubuntu系统的IO驱动，不让别人乱碰你得电脑"></a>卸载ubuntu系统的IO驱动，不让别人乱碰你得电脑</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> xserver-xorg-input-all <span class="token comment"># 安装</span><span class="token function">sudo</span> <span class="token function">apt</span> autoremove xserver-xorg-input-all <span class="token comment"># 卸载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wifi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-dbackup</title>
      <link href="/2023/01/16/hexo-dbackup/"/>
      <url>/2023/01/16/hexo-dbackup/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1997527356&auto=1&height=66"></iframe></div><h2 id="换机操作前"><a href="#换机操作前" class="headerlink" title="换机操作前"></a>换机操作前</h2><blockquote><p>在仓库中创建一个hexo分支并设置为默认</p></blockquote><blockquote><p>在本地配置好ssh连接，并测试是否连通github</p></blockquote><blockquote><p>git clone 这个仓库，因为设置成默认分支，所以直接clone的就是hexo</p></blockquote><blockquote><p>将hexo分支下除了.git的文件全部删除，再将源文件中除了.deploy_git的所有文件拷贝到这里，如果安装了主题，需要将主题中的.git文件夹删除。原理就是hexo的源码和配置不会上传到github，只是上传的.deploy_git里面通过hexo g这个命令生成的静态文件，.deploy_git里面的文件会上传到哪里，这个你在项目目录_config.yaml中配置的，这里配置了上传到哪里，上传到哪个分支，因为这个.deploy_git是可以根据hexo g来生成，所以不用上传,即是说： <code>新拉下来的这个仓库是存放源代码的，如果是第一次做这个操作，需要将其他的文件全部删除，只留下一个.git文件夹，这是仓库信息，然后将源代码里面的除了.deploy_git的所有数据全部复制过来</code></p></blockquote><blockquote><p>添加一个.gitignore文件(可选)</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">.DS_StoreThumbs.dbdb.json<span class="token important">*.log</span>node_modules/public/.deploy<span class="token important">*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>git add .</p></blockquote><blockquote><p>git commit -m “desc”</p></blockquote><blockquote><p>git push origin</p></blockquote><hr><h2 id="换了电脑之后"><a href="#换了电脑之后" class="headerlink" title="换了电脑之后"></a>换了电脑之后</h2><blockquote><p>配置好git的ssh连接</p></blockquote><blockquote><p>安装好Node</p></blockquote><blockquote><p>sudo npm install hexo-cli-g</p></blockquote><blockquote><p>git cloen 备份仓库</p></blockquote><blockquote><p>cd xxx.github.io</p></blockquote><blockquote><p>npm install</p></blockquote><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><blockquote><p>hexo g</p></blockquote><blockquote><p>hexo d</p></blockquote><p>就可以开始写博客了</p><blockquote><p>如果在已经编辑过的电脑上写博客，那么还需要git pull更新一下</p></blockquote><h2 id="多端操作"><a href="#多端操作" class="headerlink" title="多端操作"></a>多端操作</h2><blockquote><p>在新机子上clone仓库，clone的是源代码分支,然后安装依赖，开始写博客，如果新机子上以前有这个仓库，那么需要git pull更新一下再写</p></blockquote><blockquote><p>在clone的这个仓库中，可以直接写博客，不用删除什么，也可以直接hexo -g -d来将静态页面推送到github，但是每次写完了，静态代码推送完了，然后删除.deploy_git文件夹，最后通过git将源码上传到仓库。</p></blockquote><h2 id="git配置ssh"><a href="#git配置ssh" class="headerlink" title="git配置ssh"></a>git配置ssh</h2><blockquote><p>ssh-keygen -t rsa -C “邮箱” 通过这个来生成rsa密钥</p></blockquote><blockquote><p>生成的ras存放在用户目录下的.ssh文件夹中</p></blockquote><blockquote><p>cat id_rsa.pub 将公钥填写到github</p></blockquote><blockquote><p>ssh -T <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;</a> 测试是否连上github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cloud</title>
      <link href="/2023/01/15/cloud/"/>
      <url>/2023/01/15/cloud/</url>
      
        <content type="html"><![CDATA[<h2 id="购买vps"><a href="#购买vps" class="headerlink" title="购买vps"></a>购买vps</h2><blockquote><p><a href="https://racknerd.com/"><code>racknerd</code></a></p></blockquote><blockquote><p>username: <a href="mailto:&#55;&#x34;&#x39;&#x30;&#x36;&#x32;&#x38;&#55;&#x30;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;">&#55;&#x34;&#x39;&#x30;&#x36;&#x32;&#x38;&#55;&#x30;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;</a></p></blockquote><blockquote><p>password: 20021218lqs</p></blockquote><h2 id="购买DomainName"><a href="#购买DomainName" class="headerlink" title="购买DomainName"></a>购买DomainName</h2><blockquote><p><a href="https://www.namesilo.com/"><code>namesilo</code></a></p></blockquote><blockquote><p>username: liqisong</p></blockquote><blockquote><p>password: @20021218Lqs</p></blockquote><h2 id="管理域名"><a href="#管理域名" class="headerlink" title="管理域名"></a>管理域名</h2><blockquote><p><a href="https://dash.cloudflare.com/"><code>cloudflare</code></a></p></blockquote><blockquote><p>username: <a href="mailto:&#x37;&#x34;&#57;&#x30;&#54;&#50;&#x38;&#55;&#48;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#x37;&#x34;&#57;&#x30;&#54;&#50;&#x38;&#55;&#48;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a></p></blockquote><blockquote><p>password: @20021218Lqs</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>theme-install</title>
      <link href="/2023/01/15/theme-install/"/>
      <url>/2023/01/15/theme-install/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1869507838&auto=1&height=66"></iframe></div><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置-主要还是看项目的-config-yml和主题的-config-yml"><a href="#配置-主要还是看项目的-config-yml和主题的-config-yml" class="headerlink" title="配置(主要还是看项目的_config.yml和主题的_config.yml)"></a>配置(主要还是看项目的_config.yml和主题的_config.yml)</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改主目录中 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://lqs-1.github.io</code>）。</li><li>建议修改目录中 <code>_config.yml</code> 的两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改目录中 <code>_config.yml</code> 的 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> <span class="token number">404</span>.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token number">404</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"Oops～，我崩溃了！找不到你想要的页面 :("</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找   </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)     </li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.      </li><li>注意每个二级菜单模块前要加 <code>-</code>.     </li><li>注意缩进格式  </li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Music        <span class="token key atrule">url</span><span class="token punctuation">:</span> /music        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">--save</span> hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置。</p><h3 id="添加网易云音乐BGM"><a href="#添加网易云音乐BGM" class="headerlink" title="添加网易云音乐BGM"></a>添加网易云音乐BGM</h3><p>首先打开网易云网页版，找到想听的歌曲，然后点击生成外链</p><p>复制如下代码：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">&lt;div align="middle"<span class="token punctuation">></span>这里粘贴刚刚复制的代码&lt;/div<span class="token punctuation">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">&#123;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p>]]></content>
      
      
      <categories>
          
          <category> 博客部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
