---
title: 八股文
top: false
cover: false
toc: true
mathjax: true
date: 2023-02-14 10:16:00
password:
summary: java面试八股文
tags: 面试
categories: 面试题
---

# 面向对象的特征
## 封装

封装隐藏了类的内部实现机制，就和方法封装了一些内部实现一样，可以在不影响使用的情况下改变类的内部的结构同时保护了数据。增加了代码的可维护性以及便于修改。封装好的代码可以复用，增加了代码的复用性。

## 继承

子类可以使用父类的方法，猫狗都是动物，可以继承相同的属性，同时写自己不同的方法，是一种复用的概念。也是增加了代码的复用性。

## 多态

第一要有继承，第二要有重写，第三父类引用指向子类对象。增加了代码的可移植性，健壮性，灵活性。

# 强软弱虚Java中的引用类型
## Java中的引用类型有哪几种

### 强引用
我们平时new的对象都是强引用，只要有引用指向这个对象，这个对象就不会被回收（gc的时候），如何让引用没有指向？那就是引用对象=null，在gc的时候就会被回收。有指向的时候不会被回收。

### 软引用
被SoftReference包装的对象，表示有一个引用对象指向SoftRefrence是强引用，而SoftRefrence指向被包装的对象为软引用。调用get方法可以拿到这个软引用对象。在内存空间充足的情况下不会被gc回收，在空间不足的时候软引用会自动gc回收。空间狗的时候，随便分配，当强引用要分配空间，且空间不足的时候，就会将软引用挤掉。一般在缓存中会经常使用软引用。

### 弱引用
被WeakRefrence包装的对象，表示有一个引用对象指向WeakRefrence是强引用，而WeakRefrence指向被包装的对象为弱引用，调用get方法可以拿到这个弱引用对象，不管内存空间够不够，都会被gc回收。和ThreadLocal的关系比较大。

### 虚引用（不重要）
被PhantomReference包装的对象，不能获取到这个对象，get方法返回的是null，不是给业务人员用的，虚引用指向的对象是给gc回收对象用的，堆外内存使用（不归jvm管的内存），如果一个对象管理了一个堆外内存，当这个对象被干掉的时候，这个堆外的内存应该也被干掉，虚引用就是解决这个问题的，关联一个引用队列。
虚引用，顾名思义，就是形同虚设，与其他几种引用都不太一样，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用

### 引用队列（ReferenceQueue）（不重要）
引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。ReferenceQueue内部数据结构是一个链表，链表里的元素是加入进去的Reference实例，然后通过wait和notifyAll与对象锁实现生产者和消费者，通过这种方式模拟一个队列。ReferenceQueue是使用wati()和notifyAll()实现生产者和消费者模式的一个具体场景。

## ThreadLocal你了解吗
使用弱引用做的，第一感觉，ThreadLocal是个容器，可以给里面装对象，可以指定里面装什么类型的对象，装的也是引用，指定的是对象。特点是在同一个线程中才能读到数据。
给ThreadLocal中填充对象的时候，会拿到当前线程，然后获取当前线程的map，然后将值保存到当前map中，每个线程的map都是独立的，所以ThreadLocal只能在同一个线程中共享数据。
给Theadlocal中填充值的时候，最终是填充到当前线程的map中，而我们set的时候只是传递了value，key没有我们自己传递，这个key就是ThreadLocal对象
总体流程就是填充值的时候，拿到当前线程，再拿到当前线程的map，往这个map填充东西的时候，key是ThreadLocal对象，value是我们要保存的数据，在填充map的时候，使用了一个Entry出来，这个Entry继承了WeakRefrence对象，在这里调用了WeakRefrence的构造方法，把key的引用设置成了弱引用，意思就是说创建ThreadLoacl的时候有一个强引用指向她，在set值的时候，map的key还有一个弱引用指向它。

## ThreadLocal应用在什么地方
Spring框架的@Trasactional注解，数据库连接对象都放在ThreadLocal中，在方法中调用其他方法的时候都用的同一个连接对象，这样才能处理事务。

## ThreadLocal会产生内存泄露你了解吗
创建ThreadLoacl的时候有一个强引用指向她，在set值的时候，map的key还有一个弱引用指向它，这样在ThreadLocal不用的时候，可以将引用设置为null，gc可以直接回收，如果把key指向ThreadLocal这个引用设置为强引用，那么如果map有值的话，ThreadLocal就不会被回收，就会造成内存泄露。在使用了ThreadLocal的值之后，如果不将map的值移除，那么value的值也是强引用也会导致内存泄露问题，所以当ThreadLocal对象使用完成之后一定要用remove方法清除map的值。弱引用解决key，remove解决value。value不能使用弱引用，主要是因为没有一个强引用指向value，只有一个弱引用的话，会直接gc掉。

# ACID是靠什么保证的
原子性：由undolog日志来保证，他记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

一致性：由原子性，隔离性，持久性共同保证。

隔离性：是由MVCC来保证，事务之间相互隔离，多版本并发控制。

持久性：是由redolog来保证的，mysql修改数据的时候会在redolog中记录一份日志数据，就栓数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。

# BeanFactory和ApplicationContext区别


